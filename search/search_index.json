{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Neops product documentation","text":"<p>Neops represents a groundbreaking approach to network power that transcends traditional task automation.  It\u2019s designed to enhance productivity, enabling you to focus on what you do best\u2014your core competencies.  With Neops, you\u2019ll experience a seamless integration of intelligent solutions that streamline operations  and free up your time for strategic initiatives.</p> <p>Stay tuned! Comprehensive documentation is on the way to help you unlock the full potential of Neops and elevate  your efficiency to new heights.</p>"},{"location":"legacy/00-index/","title":"Overview","text":""},{"location":"legacy/00-index/#about","title":"About","text":"<p>neops, the smart way to network programmability.</p> <p>The key to be competitive tomorrow lies in an effective network automation that is closely integrated into your business processes. neops was built for complex enterprise and MSP environments and empowers you to automate and integrate on the fast-track. Many organizations invest heavily in enabling their network teams to learn to code and to automate. neops builds on those skills and helps to realize value faster by providing a modular platform that takes care of the heavy lifting. This lets your engineers focus on creating custom network &amp; business logic, while neops provides the overview, tools and mechanisms to handle the management part.</p> <p>For more information request a demo here.</p>"},{"location":"legacy/00-index/#resources","title":"Resources","text":"<p>Below you can find links to other resources related to neops:</p> <ul> <li>zebbra has built neops</li> <li>Acknowledgments for documentation of used projects at neops.</li> <li>Docker Containers at quay.io (private).</li> <li>Neops NPM registry for available NPM packages</li> </ul>"},{"location":"legacy/00-index/#roadmap","title":"Roadmap","text":"<p>We are currently working hard on the roadmap for 2021/2022. Stay tuned!</p>"},{"location":"legacy/00-index/#versioning","title":"Versioning","text":"<p>We use SemVer for versioning. For the versions available, see the tags on this repository.</p> <p>Note: Upgrading Neops requires you to sequentially install all minor releases, if not stated otherwise</p> <p>Examples:</p> <ul> <li>Upgrade from v1.0 to v1.1: Install directly</li> <li>Upgrade from v1.0 to v1.2: Install v1.1 first</li> <li>Upgrade from v1.0 to v1.x: Install v1.1, ..., v1.(x-1) first</li> </ul>"},{"location":"legacy/00-index/#authors","title":"Authors","text":"<ul> <li>zebbra AG, Bern, Switzerland</li> <li>Claudio Siegenthaler - Frontend - cloedu87</li> <li>Leandro Lerena - Backend - leandrolerena</li> <li>Marcel W\u00e4lti Rettenmund - UX - waleburg</li> <li>Roland Mamie - Networking and backend - rmamie</li> <li>Simon Obi - Backend - obisimon</li> </ul> <p>And the whole Zebbra Team!</p>"},{"location":"legacy/00-index/#license","title":"License","text":"<p>Currently neops is released under a proprietary license.</p>"},{"location":"legacy/00-index/#contributing","title":"Contributing","text":"<p>At this time, we are not set up to handle contributions. However, we appreciate any ideas or inputs. Please don't hesitate to contact us via e-mail.</p> <p>If you are a developer, you can also read our private contribution guidelines for details on our code of conduct.</p>"},{"location":"legacy/00-index/#acknowledgments","title":"Acknowledgments","text":"<ul> <li>Hat tip to anyone whose code was used</li> <li>Vue best frontend framework out there</li> <li>Vuetify material design component framework based ono vuejs</li> <li>Django as backend engine</li> <li>Celery for worker distribution</li> <li>nornir and its community for their awesome work!</li> <li>jinja2 the powerful template engine</li> </ul>"},{"location":"legacy/05-usage/","title":"Usage","text":""},{"location":"legacy/05-usage/#network-search","title":"Network Search","text":"<p>The network search view gives you an overview over the entities <code>Location/Group</code>, <code>Devices</code>, <code>Interfaces</code> and <code>Clients</code> (see Entities). All three views display the search related elements. In addition, the topology of the searched network elements is displayed.</p> <p></p> <p>Relevant data regarding the entities (facts, checks and global data) is searchable via the search bar.</p> <p></p>"},{"location":"legacy/05-usage/#search-terms","title":"Search Terms","text":"<p>Search terms are composed by [key]: [value] and put together by the logical operators AND/OR (optionally NOT). Or additionally full text searches are possible as well.</p>"},{"location":"legacy/05-usage/#keys","title":"Keys","text":"<p>Possible keys are suggested. They are composed hierarchically over the full data structure. For example if you have facts on devices stored under the key of VLANs like the following:</p> <pre><code>  \"vlans\": [\n    {\n      \"name\": \"default\",\n      \"status\": \"active\",\n      \"vlan_id\": \"1\",\n      \"interfaces\": [\n        \"Gi0/1\",\n      ]\n    },\n    {\n      \"name\": \"MGMT\",\n      \"status\": \"active\",\n      \"vlan_id\": \"10\",\n      \"interfaces\": [\n        \"Gi0/1\",\n        \"Gi0/2\"\n      ]\n    },\n    {\n      \"name\": \"CLIENT-A\",\n      \"status\": \"active\",\n      \"vlan_id\": \"100\",\n      \"interfaces\": [\n        \"Gi0/1\",\n        \"Gi3/0\",\n        \"Gi3/1\"\n      ]\n    },\n    {\n      \"name\": \"CLIENT-B\",\n      \"status\": \"active\",\n      \"vlan_id\": \"101\",\n      \"interfaces\": [\n        \"Gi0/1\",\n        \"Gi3/2\",\n        \"Gi3/3\"\n      ]\n    },\n  ],\n</code></pre> <p>You are able to filter the elements where one device has VLAN XY configured by using the key <code>devices.facts.vlans.name</code> (<code>devices</code> = access to the device elements, <code>facts</code> = access to the facts of the device, <code>vlans</code> access to the facts key, <code>name</code> key within the facts).</p> <p>Then, the search term to get all elements where VLAN <code>CLIENT-A</code> is configured will be <code>devices.facts.vlans.name: CLIENT-C</code></p> <p>If you are on the interface view, with this search all interfaces of the filtered devices are show. But this is probably not what you want. To search only the interfaces where the specific VLAN is configured, then you need more specific information, like VLAN facts on the interfaces. As an example on Interface <code>GigabitEthernet0/1</code>:</p> <pre><code>  \"vlans\": [\n    {\n      \"name\": \"default\",\n      \"status\": \"active\",\n      \"vlan_id\": \"1\",\n    },\n    {\n      \"name\": \"MGMT\",\n      \"status\": \"active\",\n      \"vlan_id\": \"10\",\n    },\n    {\n      \"name\": \"CLIENT-A\",\n      \"status\": \"active\",\n      \"vlan_id\": \"100\",\n    },\n    {\n      \"name\": \"CLIENT-B\",\n      \"status\": \"active\",\n      \"vlan_id\": \"101\",\n    },\n  ],\n</code></pre> <p>Or on <code>GigabitEthernet3/1</code>:</p> <pre><code>  \"vlans\": [\n    {\n      \"name\": \"CLIENT-A\",\n      \"status\": \"active\",\n      \"vlan_id\": \"101\",\n    },\n  ],\n</code></pre> <p>With the interface related search term <code>interfaces.facts.vlans.name: CLIENT-A</code> you will get interfaces Gi0/1, Gi3/0 and Gig3/1. And in device and location view, you'd get the related devices or locations with interfaces that match the above search.</p>"},{"location":"legacy/05-usage/#values","title":"Values","text":"<p>A <code>*</code> can be uses as a wildcard. For exact matches use double quotes <code>\"</code>.</p> <p>Strings within facts in a key name with <code>ip</code> in it, are tried to be stored as ip addresses. This gives you the ability to search within ip addresses in a subnet. Entering the network and subnet length in double quotes like <code>\"192.0.2.16/28</code> will give you all elements that contains a ip address in the range 192.0.2.16 - 192.0.2.31 in the result set.</p>"},{"location":"legacy/05-usage/#operators","title":"Operators","text":"<p>Operators <code>AND</code>, <code>OR</code> and <code>NOT</code> have to be uppercase. Parentheses can be used for logical ordering.</p>"},{"location":"legacy/05-usage/#ressources","title":"Ressources","text":"<p>elastic query string search documentation</p>"},{"location":"legacy/05-usage/#saved-searches","title":"Saved Searches","text":"<p>To easily reuse complex search terms, you can save and name them with the disk sign on the right.</p> <p>To find the saved search term, enter the defined name. Saved searches are per default added in front of the term with the <code>AND</code> operator added.</p>"},{"location":"legacy/05-usage/#executecreate-tasks","title":"Execute/Create Tasks","text":"<p>see tasks</p>"},{"location":"legacy/05-usage/#tasks-of-implemented-providers","title":"Tasks of Implemented Providers","text":"<p>see tasks, providers and provider overview</p>"},{"location":"legacy/05-usage/#configuration-history-and-rollback","title":"Configuration History and Rollback","text":"<p>The Discovery Provider saves the configuration for Devices and Interfaces to neops.</p> <p>The Configuration History can be accessed over the Device List and the Edit Button</p> <p></p> <p>The you have an overview of the saved configurations and the ability to compare them.</p> <p></p> <p>To Rollback a Device to a given state push the time backwards button, the device will be set to the state of the configuration on the right side. The Rollback operation is performed by the Device Rollback Provider</p> <p>!&gt; use this functionality with caution</p>"},{"location":"legacy/05-usage/#authentication-roles-rights-and-permissions","title":"Authentication, Roles, Rights and Permissions","text":""},{"location":"legacy/05-usage/#authentication","title":"Authentication","text":"<p>neops.io supports 3 different Authentication Providers:</p> <ul> <li>no Authentication</li> <li>Authentication against Local User Database (Django)</li> <li>Authentication against Keycloak, with OAuth2.0 (Backends like Oauth, LDAP and others supported by Keycloak)</li> </ul>"},{"location":"legacy/05-usage/#roles-rights-and-permissions","title":"Roles, Rights and Permissions","text":"<p>neops.io has it's own permission system. We grant access based on roles (Role assignments are set in Keycloak or in the Local User Database). Roles are linked to Tasks and Device Groups with three different type of permissions (Read, Execute, Write). Those Permissions are implicit as soon you have write permissions to an element you will have permissions to read and execute as well. That a user is able to execute or modify a Task on a given Device he need at least execute or write permission on both Elements with any given role.</p> <p>To grant access to permission management or other functionality there are dedicated permission elements to grant access on (such as can a user create a task).</p>"},{"location":"legacy/05-usage/#permission-management","title":"Permission Management","text":"<p>To edit permissions go to Settings -&gt; Permissions.</p>"},{"location":"legacy/05-usage/#role-permissions","title":"Role Permissions","text":"<p>In the first tab you have all existent roles with their default permissions if a element (Task, Device Group or Permission Element) does not have an explicit set permission the default permission are set. With those default permissions you have the ability to go with the least privilege principle (no default permission) or not (set default permissions)</p>"},{"location":"legacy/05-usage/#permission-elements","title":"Permission Elements","text":"<p>To grant access to task creation, permission settings or any other base functionally use the \"UI Elements\" tab. The needed permission (read, write, execute) for an action is related to the implementation. But basicity it should be self explained such as for the permission settings only read and write are used.</p> <p>Those permissions are always related to roles.</p>"},{"location":"legacy/05-usage/#permission-on-tasks","title":"Permission on Tasks","text":"<p>Grant access to a task, read, execute or edit (write) the task.</p> <p>Those permissions are always related to roles.</p>"},{"location":"legacy/05-usage/#permission-on-device-groups","title":"Permission on Device Groups","text":"<p>Grant access to a Device Groups, Devices, Interfaces and Clients. As soon as a Device is in a permitted Device Group for a given role, those person has access to any Device related Interfaces or Clients as well.</p> <p>Those permissions are always related to roles.</p>"},{"location":"legacy/10-facts/","title":"Facts","text":"<p>Facts in neops.io are flexible data structures stored as JSON in the database. Every fact/data structure is stored under a given key. Facts are collected by fact tasks.</p> <p>They are representing a state at a given time. And facts are not only facts, they can represent states as well.</p> <p>Examples of facts:</p> <ul> <li>Software release running on a network device</li> <li>A configuration parameter eg. the log server</li> <li>State of a routing protocol neighbor ship</li> <li>Information from peripheral systems, like CMDB and others</li> <li>Information about service SLA</li> <li>Information about physical device access</li> </ul> <p>Facts can be stored on every entity known in neops.io (see Entities)</p> <p>Data structures of facts are searchable.</p> <p>They are collected by FACTS Tasks/Providers and they need a key to be stored.</p> <p>!&gt; Choose the facts key wisely, because if the key contains ip (pattern <code>*.ip.*</code>) an ip address (yes ipv6 as well) or an empty string is expected. otherwise the content is skipped for searching.</p> <p>Example</p> <pre><code>  \"napalm_facts\": {\n    \"fqdn\": \"dsw01.neops.io\",\n    \"model\": \"IOSv\",\n    \"uptime\": 2547840,\n    \"vendor\": \"Cisco\",\n    \"hostname\": \"sw01\",\n    \"os_version\": \"vios_l2 Software (vios_l2-ADVENTERPRISEK9-M), Version 15.2(CML_NIGHTLY_20180619)FLO_DSGS7, EARLY DEPLOYMENT DEVELOPMENT BUILD, synced to  V152_6_0_81_E\",\n    \"serial_number\": \"93F8UGICVB2\",\n    \"interface_list\": [\n      \"GigabitEthernet0/0\",\n      \"GigabitEthernet0/1\",\n      \"GigabitEthernet0/2\",\n      \"GigabitEthernet0/3\",\n      \"GigabitEthernet1/0\",\n      \"GigabitEthernet1/1\",\n      \"GigabitEthernet1/2\",\n      \"GigabitEthernet1/3\",\n      \"GigabitEthernet2/0\",\n      \"GigabitEthernet2/1\",\n      \"GigabitEthernet2/2\",\n      \"GigabitEthernet2/3\",\n      \"GigabitEthernet3/0\",\n      \"GigabitEthernet3/1\",\n      \"GigabitEthernet3/2\",\n      \"GigabitEthernet3/3\",\n      \"Vlan10\"\n    ]\n  },\n  \"vlans\": [\n    {\n      \"name\": \"default\",\n      \"status\": \"active\",\n      \"vlan_id\": \"1\",\n      \"interfaces\": [\n        \"Gi0/1\",\n        \"Gi0/2\",\n        \"Gi0/3\",\n        \"Gi1/2\",\n        \"Gi1/3\",\n        \"Gi2/0\",\n        \"Gi2/1\",\n        \"Gi2/2\",\n        \"Gi2/3\",\n        \"Gi3/0\",\n        \"Gi3/1\",\n        \"Gi3/2\",\n        \"Gi3/3\"\n      ]\n    },\n    {\n      \"name\": \"MGMT\",\n      \"status\": \"active\",\n      \"vlan_id\": \"10\",\n      \"interfaces\": []\n    },\n    {\n      \"name\": \"CLIENT-A\",\n      \"status\": \"active\",\n      \"vlan_id\": \"100\",\n      \"interfaces\": []\n    },\n    {\n      \"name\": \"CLIENT-B\",\n      \"status\": \"active\",\n      \"vlan_id\": \"101\",\n      \"interfaces\": []\n    },\n    {\n      \"name\": \"CLIENT-C\",\n      \"status\": \"active\",\n      \"vlan_id\": \"102\",\n      \"interfaces\": []\n    },\n    {\n      \"name\": \"fddi-default\",\n      \"status\": \"act/unsup\",\n      \"vlan_id\": \"1002\",\n      \"interfaces\": []\n    },\n    {\n      \"name\": \"token-ring-default\",\n      \"status\": \"act/unsup\",\n      \"vlan_id\": \"1003\",\n      \"interfaces\": []\n    },\n    {\n      \"name\": \"fddinet-default\",\n      \"status\": \"act/unsup\",\n      \"vlan_id\": \"1004\",\n      \"interfaces\": []\n    },\n    {\n      \"name\": \"trnet-default\",\n      \"status\": \"act/unsup\",\n      \"vlan_id\": \"1005\",\n      \"interfaces\": []\n    }\n  ],\n</code></pre>"},{"location":"legacy/15-checks/","title":"Checks","text":"<p>Checks in neops.io are fixed data structures with a state (ok, nok, check execution failed), a reason and flexible metric values. Every check result is stored under a given key.</p> <p>They are representing a defined state at a given time</p> <p>Examples of checks:</p> <ul> <li>Verify if a fact meets the requirement:</li> <li>Is the correct software version installed?</li> <li>Is the BGP Session up</li> <li>Directly check a state of an element:</li> <li>Is this destination reachable over ICMP</li> <li>Are there any software advisories for this device</li> <li>Aggregation of other check results:</li> <li>Has every device at a location the correct software version</li> <li>Has a device the correct software version and are there no critical bugs in this software release</li> </ul> <p>Checks can be stored on every entity known in neops.io (see Entities)</p> <p>Data structures of checks are searchable.</p> <p>They are collected by Check Tasks/Providers and they need a key to be stored.</p> <p>Example of a check data structure</p> <pre><code>{\n  \"mgmt_vlan_check\": {\n    \"id\": 67,\n    \"date\": \"2020-09-11T07:07:47.190Z\",\n    \"reason\": \"MGMT VLAN does exist\",\n    \"result\": \"ok\",\n    \"metrics\": {}\n  }\n}\n</code></pre> <p>Checks can store relations to facts or other checks where they are based on, to drill down the reason on a check result.</p>"},{"location":"legacy/15-checks/#pre-and-post-run-checks","title":"Pre and Post Run Checks","text":"<p>You can use check task as pre or post run of other tasks. If a check fails as a pre or post run task (in a task graph) it prevents the execution of other task steps for the failed element.</p>"},{"location":"legacy/20-tasks/","title":"Tasks","text":"<p>neops.io tasks are performing actions (collecting facts, make changes, interact with peripheral systems).</p> <p>There are currently 4 types of tasks implemented</p> <ul> <li>CONFIGURE - configure network devices</li> <li>FACTS - collecting facts</li> <li>CHECK - check states based on facts</li> <li>EXECUTE - generic task for troubleshooting purpose, interact with peripheral systems (if it's not related to facts) or others</li> </ul> <p>All Tasks are based on providers that execute the tasks. A task is a parameterized provider instance.</p> <p>A task passes the required configuration (parameterized) to a provider to make it runnable. These requirements are defined in a providers json schema. A list of the providers and their required configuration json schema is here.</p> <p>A check is a task, which does not manipulate the network state in any way.</p>"},{"location":"legacy/20-tasks/#create-new-task-or-check","title":"Create new task or check","text":"<p>To create a new task navigate to the task menu in the main navigation and click on create.</p> <p></p> <p></p> <p>The task form consists of general task fields and specific fields depending on the provider (read more on how to to create your own provider and add form fields using JSON Form)</p> <p>After saving the task, it will appear in your task list.</p> <p></p>"},{"location":"legacy/20-tasks/#execute-tasks","title":"Execute Tasks","text":"<p>Navigate to your network, and select the elements you want to run the task on.</p> <p></p> <p>Select the task in the bottom bar and click on preview. Enter a description for the process and start.</p> <p></p> <p>You can learn more about how network elements are resolved in the provider section.</p> <p>Depending on the options set within the provider it is possible that it is supported to run from all entities or only from one entity. For example if you have a configure task on a interface, it's better you select only the target interfaces than select a device group and run the task on all interfaces of the devices in this device group. For more information see the provider properties.</p>"},{"location":"legacy/20-tasks/#task-parameters","title":"Task parameters","text":"<p>Task parameters are used to describe the task itself and how it is acting.</p> <p>General task parameters are available in each task. Fields written in bold are mandatory.</p> Field Description Name A human readable name for the task Description A human readable description for the task Unique task identifier Can be assigned to use the task over our API Run Filter Additional filter, using the elastic query style Provider The provider (will expand the form with dynamic parameters from the provider) Pre run tasks Tasks which have to run before this task (see task graph for more information) Post run tasks Tasks which have to run after this task (see task graph for more information)"},{"location":"legacy/20-tasks/#additional-input-parameters-json-scheme-for-running-the-task","title":"Additional input parameters (JSON scheme for running the task)","text":"<p>Providers describe additional input parameters as JSON Schema. They are required to run a task.</p> <p>When creating a task, a web Form is rendered based on the task JSON schema to get the required input values.</p> <p>For more information how to build such a JSON Schema look in Appendix under JSON Form</p>"},{"location":"legacy/20-tasks/#pre-and-post-running-tasks-task-graph","title":"Pre and post running tasks (task graph)","text":"<p>For some tasks, like configurations or checks, it's essential to have accurate (actual) data. They are based on current facts or states, which should be collected in front of the task. Such supporting tasks can be referenced as pre- or post-running tasks</p> <p>Neops tasks can be combined and reused in other tasks by setting them as a pre run or post run task. The task resolver will then find a valid sequence to run the tasks.</p>"},{"location":"legacy/20-tasks/#task-sequencing","title":"Task sequencing","text":"<p>Consider the case where you want to run two tasks, and perform an integrity check after each.</p>"},{"location":"legacy/20-tasks/#independent-tasks","title":"Independent tasks","text":"<p>If the tasks are completely independent, you may run them independently:</p> <pre><code>graph LR\n    A[Task 1: Collect Facts]\n    C[Task 2: Integrity Check]\n    A --&gt; C</code></pre> <p>And</p> <pre><code>graph LR\n    B[Task 3: Configuration Task]\n    C[Task 2: Integrity Check]\n    B --&gt; C</code></pre>"},{"location":"legacy/20-tasks/#dependent-tasks","title":"Dependent tasks","text":"<p>However, if you have dependencies between 2 or more task, you can specify pre and post run tasks accordingly.</p> <p>Here, a dependency of task 1 and task 2 is configured by setting task 1 as a pre run task of task 2.</p> <pre><code>graph LR\n    A[Task 1: Collect Facts]\n    B[Task 3: Configuration Task]\n    C[Task 2: Integrity Check]\n    A --&gt; B\n    B --&gt; C\n    A --&gt; C</code></pre> <p>Which will be sequenced by the task resolver as following:</p> <pre><code>graph LR\n    A[Task 1: Collect Facts]\n    B[Task 3: Configuration Task]\n    C1[Task 2: Integrity Check]\n    C2[Task 2: Integrity Check]\n    A --&gt; C1\n    C1 --&gt; B\n    B --&gt; C2</code></pre>"},{"location":"legacy/20-tasks/#optimize-task-sequence","title":"Optimize task sequence","text":""},{"location":"legacy/20-tasks/#removal-of-consecutively-repeating-tasks","title":"Removal of consecutively repeating tasks","text":"<p>Consider an example with pre and post run tasks, similar to the previous. Here, a pre run task is added to task 1 and 2, such that the integrity check is mandatory before a change can occur:</p> <pre><code>graph LR\n    A1[Task 1: Collect Facts]\n    C[Task 2: Integrity Check]\n    C -- pre --&gt; A1\n    A1 -- post --&gt; C</code></pre> <p>which expands to:</p> <pre><code>graph LR\n    A1[Task 1: Collect Facts]\n    C11[Task 2: Integrity Check]\n    C12[Task 2: Integrity Check]\n    C11 --&gt; A1\n    A1 --&gt; C12</code></pre> <p>And</p> <pre><code>graph LR\n    A2[Task 3: Configuration Task]\n    C[Task 2: Integrity Check]\n    C[Task 2: Integrity Check]\n    C -- pre --&gt; A2\n    A2 -- post --&gt; C</code></pre> <p>which expands to:</p> <pre><code>graph LR\n    A2[Task 3: Configuration Task]\n    C21[Task 2: Integrity Check]\n    C22[Task 2: Integrity Check]\n    C21 --&gt; A2\n    A2 --&gt; C22</code></pre> <p>Setting Task 1 as pre run task of Task 2, the following task graph is produced:</p> <pre><code>graph LR\n    A1[Task 1: Collect Facts]\n    A2[Task 3: Configuration Task]\n    C[Task 2: Integrity Check]\n    C -- pre --&gt; A1\n    A1 -- post --&gt; C\n    C -- pre --&gt; A2\n    A2 -- post --&gt; C\n    A1 --&gt; A2</code></pre> <p>which expands to:</p> <pre><code>graph LR\n    A1[Task 1: Collect Facts]\n    A2[Task 3: Configuration Task]\n    C11[Task 2: Integrity Check]\n    C12[Task 2: Integrity Check]\n    C11 --&gt; A1\n    A1 --&gt; C12\n    C21[Task 2: Integrity Check]\n    C22[Task 2: Integrity Check]\n    C21 --&gt; A2\n    A2 --&gt; C22\n    A1 --&gt; A2</code></pre> <p>In this example, a sequencing would result in performing the integrity check two times in a row (as we have 2 tasks and 4 integrity checks):</p> <pre><code>graph LR\n    A1[Task 1: Collect Facts]\n    A2[Task 3: Configuration Task]\n    C11[Task 2: Integrity Check]\n    C12[Task 2: Integrity Check]\n    C21[Task 2: Integrity Check]\n    C22[Task 2: Integrity Check]\n    C11 -- pre task 1 --&gt; A1\n    A1 -- post task 1 --&gt; C12\n    C12 --&gt; C21\n    C21 -- pre task 2 --&gt; A2\n    A2 -- post task 2 --&gt; C22</code></pre> <p>Here, the sequence is optimized, such that no duplicates exist and task definition is fulfilled.</p> <pre><code>graph LR\n    A1[Task 1: Collect Facts]\n    A2[Task 3: Configuration Task]\n    C11[Task 2: Integrity Check]\n    C12[Task 2: Integrity Check]\n    C22[Task 2: Integrity Check]\n    C11 -- pre task 1 --&gt; A1\n    A1 -- post task 1 --&gt; C12\n    C12 -- pre task 2 --&gt; A2\n    A2 -- post task 2 --&gt; C22</code></pre>"},{"location":"legacy/20-tasks/#optimize-task-sequence-by-finding-shortest-path","title":"Optimize task sequence by finding shortest path","text":"<p>Consider the previous example with an added post run task (task 4) to task 1. Task 4 has no dependencies.</p> <pre><code>graph LR\n    A1[Task 1: Collect Facts]\n    A2[Task 3: Configuration Task]\n    C[Task 2: Integrity Check]\n    A3[Task 4: Renaming task]\n    C -- pre --&gt; A1\n    A1 -- post --&gt; C\n    C -- pre --&gt; A2\n    A2 -- post --&gt; C\n    A1 --&gt; A2\n    A1 --&gt; A3</code></pre> <p>Here, a second possible path fulfilling the requirements is introduced. Neops will find the task sequence which is shortest.</p> <p>6 Task executions (shortest)</p> <pre><code>graph LR\n    A1[Task 1: Collect Facts]\n    A2[Task 3: Configuration Task]\n    A3[Task 4: Renaming task]\n    C11[Task 2: Integrity Check]\n    C12[Task 2: Integrity Check]\n    C22[Task 2: Integrity Check]\n    C11 -- pre task 1 --&gt; A1\n    A1 -- post task 1 --&gt; C12\n    C12 -- pre task 2 --&gt; A2\n    A2 -- post task 2 --&gt; C22\n    C22 -- post task 1 --&gt; A3</code></pre> <p>7 task executions (not shortest)</p> <pre><code>graph LR\n    A1[Task 1: Collect Facts]\n    A2[Task 3: Configuration Task]\n    A3[Task 4: Renaming task]\n    C11[Task 2: Integrity Check]\n    C12[Task 2: Integrity Check]\n    C22[Task 2: Integrity Check]\n    C21[Task 2: Integrity Check]\n\n    C11 -- pre task 1 --&gt; A1\n    A1 -- post task 1 --&gt; C12\n    C12 -- post task 1 --&gt; A3\n    A3 -- post task 1 --&gt; C21\n    C21 -- pre task 2 --&gt; A2\n    A2 -- post task 2 --&gt; C22</code></pre>"},{"location":"legacy/25-provider/","title":"Providers","text":"<p>Providers are the classes used by tasks. They provide functionality and expose configuration parameters through JSON Forms to the user. Providers are running the tasks.</p> <p>This way, a provider can be written (like a function) in a generic and reusable way, while a task contains configuration which is passed to the provider.</p> <p>Neops comes with a set of providers out of the box, see built in providers.</p>"},{"location":"legacy/25-provider/#tasks","title":"Tasks","text":"<p>Tasks are instantiated Providers given arguments they can be executed from the frontend with additionally passed arguments.</p> <p>To execute a task those arguments can be used:</p> <ul> <li><code>neopsTaskId</code> or <code>uniquetaskname</code>: id or the unique name of the task to execute</li> <li><code>executeOn</code>: list of id on which elements the task should be performed (this list can be empty, see properties)</li> <li><code>executeOnType</code>: on which entity the task should be performed (see run_on_strict in properties)</li> <li><code>dryRun</code>: option if there should be no change on the device/api itself, has to be implemented by the used provider</li> <li><code>taskArguments</code>: additional run arguments for the task (see run_input_json_schema in properties)</li> </ul> <p>example GraphQL call</p> <pre><code>mutation neopsTask {\n  neopsTaskExecute (neopsTaskId: 1, executeOn: [1], executeOnType: DEVICE, dryRun: true, taskArguments: \"{}\") {\n    execution {\n      id\n      state\n      neopsTask {\n        id\n        name\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"legacy/25-provider/#properties","title":"Properties","text":"<p>They have some base properties that describe the provider.</p> <p>On which entity and how the provider has to be executed:</p> <ul> <li><code>run_on</code>: the task is executed on this entity</li> <li><code>run_on_strict</code>: describes the allowed input entities, if strict only elements of the run_on entity are allowed, otherwise the run_on entity is resolved from the given entity (eg. interface 1,2 belongs to device A, interface 3,4 belongs to device B. if run_on is set to DEVICE and run_on_strict is False: interface 1 is given the task runs on device A. vice verca if run on is set to INTERFACE and run_on_strict is False: device B is given the task runs on interface 3 and 4. if run_on_strict is True only run_on entity is supported)</li> <li><code>run_on_all_if_empty</code>: use with caution - runs on all elements if none is given (mostly used for facts providers)</li> </ul> <pre><code>run_on = RunOnEnum.DEVICE\nrun_on_strict = True\nrun_on_all_if_empty = False\n</code></pre> <p>Properties to describe the provider/task:</p> <ul> <li><code>provider_type</code>: representing the four different task types</li> <li><code>description</code>: describe what the provider will do</li> </ul> <pre><code>provider_type = ProviderTypeEnum.FACTS\ndescription = \"\"\n</code></pre> <p>Properties to describe which input parameters are required for the task instance and in the runs:</p> <ul> <li><code>json_schema</code>: JSON Form for rendering the task instance form in the frontend</li> <li><code>run_input_json_schema</code>: JSON Form for rendering the form before the task runs</li> </ul> <pre><code>json_schema = {}\nrun_input_json_schema = {}\n</code></pre>"},{"location":"legacy/25-provider/#run-cycle","title":"Run cycle","text":"<p>The run cycle definition is implemented in each neops provider. Steps can be left empty, but the order is immutable.</p> <p>Use pre run and run steps to prepare and execute.</p> # Step Description 1 Pre run on global All task arguments are passed 2 Pre run on device group Per device group. Device groups are resolved and passed 3 Pre run on clients of group Per client of group. Runs in context of group (here, groups are locations). Device group and client are resolved and passed 4 Pre run on nornir device Per nornir device. Nornir device is resolved and passed 5 Pre run on device Per device. Device is resolved and passed 6 Pre run on interface Per interface of device. Device and interface are resolved and passed 7 Pre run on clients of interface Per client of interface. Device, nornir device an dinterface are resovled and passed 8 Run on clients of interface Run equivalent for #7 9 Run on interface Run equivalent for #6 10 Run on device Run equivalent for #5 11 Run on nornir device Run equivalent for #4 12 Run on clients of group Run equivalent for #3 13 Run on device group Run equivalent for #2 14 Run on global Run equivalent for #1 <pre><code>graph LR\n    S[Start]\n    P1[Global]\n    P2[Device Group]\n    P3[Clients of Group]\n    P4[Nornir Device]\n    P5[Device]\n    P6[Interface]\n    P7[Clients of Interface]\n\n    S -- 1 pre run --&gt; P1\n    S -- 2 pre run --&gt; P2\n    P2 -- 3 pre run --&gt; P3\n    S -- 4 pre run --&gt; P4\n    P4 -- 5 pre run --&gt; P5\n    P5 -- 6 pre run --&gt; P6\n    P6 -- 7 pre run --&gt; P7\n    P7 -- 8 run --&gt; P7\n    P7 -- 9 run --&gt; P6\n    P6 -- 10 run --&gt; P5\n    P5 -- 11 run --&gt; P4\n    P3 -- 12 run --&gt; P3\n    P3 -- 13 run --&gt; P2\n    S -- 14 run --&gt; P1</code></pre> <p>For more information of the methods of the run cycle see the BaseRunCycle class.</p>"},{"location":"legacy/25-provider/#result-handling","title":"Result handling","text":"<p>Results are handled per default by the BaseResultWriter it stores the results to the database and informs the user. For preprocessing of the results. At the end of the run cycle are the methods of - BaseProcessResultCycle called. Those methods are here to modify results based on other results or use them to save information to the database like the base fact or base check provider does.</p> <p>Result Objects are generated for every related element of a task run. Within this objects the relation between elements of the entities is represented. If a task step in the run cycle fails (by an exception or set on the result object), the element itself and none of it sub elements are further processed. For example if it's unable to connect to a device no more run cycle methods related to this device (device, interfaces and clients on interfaces) are processed.</p>"},{"location":"legacy/25-provider/#inheritance","title":"Inheritance","text":"<p>For new providers inheritance from the base providers is required they brings the base functionality how a provider is executed, result handling and basic configuration, facts or check handling.</p>"},{"location":"legacy/30-provider_overview/","title":"Provider overview","text":""},{"location":"legacy/30-provider_overview/#base-providers","title":"Base Providers","text":"<p>Base providers features basic functionality to inherit providers from them.</p> <ul> <li>NeopsBaseProvider</li> <li>NeopsCheckBaseProvider</li> <li>NeopsConfigureBaseProvider</li> <li>NeopsFactsBaseProvider</li> </ul> <p>They all include the Base Run Cycle and the Base Process Result Cycle</p> <ul> <li>BaseRunCycle</li> <li>BaseProcessResultCycle</li> </ul> <p>Results are written by the Base Result Writer</p> <ul> <li>BaseResultWriter</li> </ul>"},{"location":"legacy/30-provider_overview/#main-functionality-providers","title":"Main Functionality Providers","text":"<p>Those providers are used for the main neops.io functionality.</p>"},{"location":"legacy/30-provider_overview/#generic-providers","title":"Generic Providers","text":"<p>Those providers can be used on all entities, they are mostly to maintain facts and checks.</p> <ul> <li>GenericTextFSMFactsV2</li> <li>GenericJinjaFactsProvider</li> <li>GenericJinjaCheckProvider</li> <li>GenericSimpleWorkflow</li> <li>GenericFromExcel</li> <li>GenericReportProvider</li> <li>GenericRestFactsProvider</li> </ul>"},{"location":"legacy/30-provider_overview/#device-providers","title":"Device Providers","text":"<p>Those providers are used for device specific functionality.</p> <ul> <li>DeviceJinjaConfigureProvider</li> <li>DeviceDiscoveryProvider</li> <li>DeviceJinjaExecProvider</li> </ul>"},{"location":"legacy/30-provider_overview/#interface-providers","title":"Interface Providers","text":"<p>Those providers are used for interface specific functionality.</p> <ul> <li>InterfaceJinjaConfigureProvider</li> </ul>"},{"location":"legacy/30-provider_overview/#global-providers","title":"Global Providers","text":"<p>Those providers are used for global functionality.</p> <ul> <li>GlobalMail</li> </ul>"},{"location":"legacy/30-provider_overview/#additional-providers","title":"Additional Providers","text":""},{"location":"legacy/30-provider_overview/#generic-providers_1","title":"Generic Providers","text":"<ul> <li>GenericCheckAggregation</li> <li>GenericPing</li> <li>GenericTextFSMFacts</li> </ul>"},{"location":"legacy/30-provider_overview/#device-providers_1","title":"Device Providers","text":"<ul> <li>DeviceUpgradeProvider</li> <li>DeviceUpgradeDirectProvider</li> <li>DeviceUpgradeUnattendedProvider</li> <li>DeviceRestartProvider</li> <li>DeviceRommonUpgradeProvider</li> <li>DeviceRommonUpgradeUnattendedProvider</li> <li>DeviceStackAutoUpgradeUnattendedProvider</li> <li>DeviceImageCleanUpProvider</li> <li>DeviceRollbackProvider</li> <li>DeviceNapalmFacts</li> <li>DeviceSNMPFactsProvider</li> </ul>"},{"location":"legacy/35-architecture/","title":"Architecture","text":""},{"location":"legacy/35-architecture/#principles","title":"Principles","text":"<p>neops.io as a network automation software was built with the following principles in mind</p> <ul> <li>network engineers know their network best, so network design and logic of tasks/todo\u2019s are in their responsibility</li> <li>neops.io itself has no, or as minimalistic as possible, knowledge of the network and the functionality of its devices. Information and logic about the network is brought to neops.io by tasks that are collecting information from the network or external systems.</li> <li>Facts are a central element in neops.io. They are the base upon to build the logic of tasks to deploy changes in the network</li> <li>neops.io should bring flexibility to implement functionality at different levels</li> <li>device level: change the methods of how to read and write from network devices to fit your vendors and your needs</li> <li>provider level: bring your own task providers to implement APIs of your peripheral systems or bring new features (like AI ;)) to neops.io</li> <li>task level: define the todo in your network within your tasks, so they will represent the prerequisites of your network</li> <li>permission, workflow level (planned) and triggers (planned): easy automate or delegate tasks</li> </ul>"},{"location":"legacy/35-architecture/#services","title":"Services","text":""},{"location":"legacy/35-architecture/#logical-application-overview","title":"Logical application overview","text":"<pre><code>graph TD\n    f1([Frontend])\n    b1([Backend])\n    w1([Worker])\n    w2([Worker])\n    db1[(Postgres)]\n    db2[(Elastic)]\n    n1[Network Devices]\n    n2[Network Devices]\n    f1 --&gt; | GraphQL\u00a0| b1\n    b1 --&gt; db1\n    b1 --&gt; db2\n    b1 --- | Redis | w1\n    b1 --- | Redis | w2\n    w1 --&gt; db1\n    w1 --&gt; db2\n    w2 --&gt; db1\n    w2 --&gt; db2\n    w1 --&gt; n1\n    w2 --&gt; n1\n    w1 --&gt; n2\n    w2 --&gt; n2</code></pre>"},{"location":"legacy/35-architecture/#containers","title":"Containers","text":"<p>We ship one container with different functionality. Frontend (VueJS) and Backend (python) are packed in one container.</p> <p>Depending on its start parameters the neops.io container runs as:</p> <ul> <li>Frontend/Backend</li> <li>Worker</li> <li>Scheduler</li> </ul> <p>neops.io depends on external ressources/services/containers:</p> <ul> <li>Redis - message brocker between backend/worker/scheduler</li> <li>Postgres - relational database</li> <li>Elastic Search - search database</li> <li>Keycloak - authentication service</li> </ul> <pre><code>graph TD\n    rp([Traefik Reverse Proxy])\n    bf1([neops.io Backend/Frontend])\n    bf2([neops.io Backend/Frontend])\n    w1([neops.io Worker])\n    w2([neops.io Worker])\n    s1([neops.io Scheduler])\n    db1[(Postgres)]\n    db2[(Elastic)]\n    r1[(Redis)]\n    a1([Authentication/Keycloak])\n    rp --&gt; bf1\n    rp --&gt; bf2\n    bf1 &amp; bf2 --&gt; r1\n    r1 --&gt; w1 &amp; w2\n    bf1 &amp; bf2 --- db1\n    bf1 &amp; bf2 --- db2\n    w1 &amp; w2 --- db1\n    w1 &amp; w2 --- db2\n    s1 --- db1\n    s1 --&gt; r1\n    bf1 &amp; bf2 --&gt; a1\n\n    style bf1 stroke,stroke-dasharray: 5, 5\n    style w1 stroke,stroke-dasharray: 5, 5</code></pre>"},{"location":"legacy/35-architecture/#scalingredundancy","title":"Scaling/Redundancy","text":"<p>neops.io has all its persistent data in the database, so neops.io containers can be easily run in parallel for scaling reasons.</p> <p>For scaling and/or redundancy setup of 3rd party applications (Postgres, Elastic Search, Redis and Keycloak) please refer to their documentation.</p>"},{"location":"legacy/35-architecture/#entities","title":"Entities","text":"<p>In reference to network components neops.io is currently working with the following entities:</p> <ul> <li>Device Groups - Entity to group devices</li> <li>Devices - Main entity to access network components</li> <li>Interfaces - Entity for interconnecting Devices</li> <li>Clients - Entity connected to the network</li> </ul> <p>Locations are Device Groups with additional properties like address and coordinates.</p>"},{"location":"legacy/35-architecture/#frontend","title":"Frontend","text":"<p>The frontend is build with Vue.js and accesses the backend over a GraphQL API.</p>"},{"location":"legacy/35-architecture/#backend","title":"Backend","text":"<p>Backend is based on Python and realized with Django, Celery and nornir as its main components.</p>"},{"location":"legacy/35-architecture/#models","title":"Models","text":"<p>most relevant database models:</p> <pre><code>classDiagram\n    Interface \"1\" -- \"1\" Interface\n    Device \"1\" -- \"n\" Interface\n    Device \"n\" -- \"1\" Platform\n    Platform \"n\" -- \"n\" Library\n    DeviceGroup \"n\" -- \"n\" Device\n    DeviceGroup -- Location\n    ProcessExecution \"1\" -- \"n\" Execution\n    Execution \"1\" -- \"n\" DeviceExecution\n    Execution \"n\" -- \"1\" Task\n    DeviceExecution \"n\" -- \"1\" Device\n    Execution \"1\" -- \"n\" DeviceExecutionResult\n    Device \"1\" -- \"n\" DeviceExecutionResult\n    Execution \"1\" -- \"n\" DeviceGroupExecutionResult\n    DeviceGroup \"1\" -- \"n\" DeviceGroupExecutionResult\n    Execution \"1\" -- \"n\" InterfaceExecutionResult\n    Interface \"1\" -- \"n\" InterfaceExecutionResult\n    Execution \"1\" -- \"n\" ClientExecutionResult\n    Client \"1\" -- \"n\" ClientExecutionResult\n    Device \"1\" -- \"n\" DeviceConfiguration\n    Interface \"1\" -- \"n\" InterfaceConfiguration\n    Client \"1\" -- \"n\" Interface\n    Client \"n\" -- \"1\" Location\n\n    class ProcessExecution{\n        name\n    }\n    class Execution{\n        state\n    }\n    class DeviceExecution{\n        state\n        log\n    }\n    class DeviceExecutionResult{\n        state\n        message\n    }\n    class DeviceGroupExecutionResult{\n        state\n        message\n    }\n    class InterfaceExecutionResult{\n        state\n        message\n    }\n    class ClientExecutionResult{\n        state\n        message\n    }\n    class Device{\n        hostname\n        ip\n        facts\n    }\n    class Platform{\n        name\n    }\n    class Library{\n        name\n    }\n    class Interface{\n        name\n        neighbor\n        facts\n    }\n    class Client{\n        mac\n        facts\n    }\n    class DeviceGroup{\n        name\n        facts\n    }\n    class Task{\n        name\n        provider\n        task arguments\n    }\n    class DeviceConfiguration{\n        date\n        configuration\n    }\n    class InterfaceConfiguration{\n        date\n        configuration\n    }\n    class Location {\n        address\n        lon/lat\n    }\n</code></pre>"},{"location":"legacy/35-architecture/#documents","title":"Documents","text":"<p>DeviceGroup, Device, Interface and Clients including their facts are stored as separated Indexes in Elastic Search</p>"},{"location":"legacy/35-architecture/#workerscelery","title":"Workers/Celery","text":"<p>Celery is used for the Workers they are executing the neops.io Tasks/Providers. The workers have direct access to the databases. Scheduled tasks are distributed with a redis queue. To inform the Frontend about updated information GraphQL subscription updates are triggered over different redis queues.</p>"},{"location":"legacy/35-architecture/#graphql-api","title":"GraphQL API","text":"<p>All backend Operations are available over the GraphQL API. Testing and Documentation of the API is provided by GraphiQL on your installation under <code>http(s)://NEOPS_URL/graphiql/</code></p>"},{"location":"legacy/35-architecture/#nornirtasksproviders","title":"nornir/Tasks/Providers","text":"<p>see provider</p>"},{"location":"legacy/35-architecture/#style-guide","title":"Style Guide","text":"<p>We use flake8 linting and black formatting in the backend and eslint in the frontend to style our code.</p>"},{"location":"legacy/40-appendix/","title":"Appendix","text":"<ul> <li>Jinja2</li> <li>JSON Form</li> <li>Text FSM</li> </ul>"},{"location":"legacy/40-appendix/#installation-manual","title":"Installation manual","text":"<p>An Installation manual is available for developers.</p>"},{"location":"legacy/40-appendix/#contributing","title":"Contributing","text":"<p>Our Contributing guidelines.</p>"},{"location":"legacy/CONTRIBUTING/","title":"Contributing","text":"<p>When contributing to this repository, please first discuss the change you wish to make via issue, email, or any other method with the owners of this repository before making a change.</p> <p>Please note we have a code of conduct, please follow it in all your interactions with the project.</p>"},{"location":"legacy/CONTRIBUTING/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Ensure any install or build dependencies are removed before the end of the layer when doing a build.</li> <li>Update the README.md with details of changes to the interface, this includes new environment variables, exposed ports, useful file locations and container parameters.</li> <li>Increase the version numbers in any examples files and the README.md to the new version that this Pull Request would represent. The versioning scheme we use is SemVer.</li> <li>You may merge the Pull Request in once you have the sign-off of two other developers, or if you do not have permission to do that, you may request the second reviewer to merge it for you.</li> </ol> <p>Also, check out infos about our development workflow.</p>"},{"location":"legacy/CONTRIBUTING/#code-of-conduct","title":"Code of Conduct","text":""},{"location":"legacy/CONTRIBUTING/#our-pledge","title":"Our Pledge","text":"<p>In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.</p>"},{"location":"legacy/CONTRIBUTING/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to creating a positive environment include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Examples of unacceptable behavior by participants include:</p> <ul> <li>The use of sexualized language or imagery and unwelcome sexual attention or advances</li> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or electronic   address, without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"legacy/CONTRIBUTING/#our-responsibilities","title":"Our Responsibilities","text":"<p>Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior.</p> <p>Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.</p>"},{"location":"legacy/CONTRIBUTING/#scope","title":"Scope","text":"<p>This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.</p>"},{"location":"legacy/CONTRIBUTING/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at [INSERT EMAIL ADDRESS]. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately.</p> <p>Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.</p>"},{"location":"legacy/CONTRIBUTING/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 1.4, available at http://contributor-covenant.org/version/1/4</p>"},{"location":"legacy/contribute_documentation/","title":"Contribute to the docs","text":"<p>Thank you for contributing something to our documentation.</p>"},{"location":"legacy/contribute_documentation/#taking-screenshots","title":"Taking screenshots","text":"<p>Screenshots are taken in a standardized way for better reading experience.</p> <p>To take a screenshot, please follow these points:</p> <ul> <li>Open Neops in a Chromium Browser</li> <li>Press F12 to open Dev Tools</li> <li>Press Ctrl+Shift+M to enable the device toolbar</li> <li>On the device menu, select Edit...</li> <li>Select Desktop and a resolution of 1200x500</li> </ul> <p></p> <ul> <li>Capture a screenshot using the menu option Capture Screenshot</li> </ul> <p></p>"},{"location":"legacy/development/","title":"Development","text":"<p>We use a light version of gitflow for development. Please refer to the image for more insight and check out Gitflow documentation. The Tool 'gitflow' is currently not used by us.</p> <p>Key points:</p> <ul> <li>Tags represent releases and are normally on commits in the master branch. On hotfixes for past versions, the tags may not be available on the master branch.</li> <li>Master branch is stable, but not every commit has to result in a release.</li> <li>Development branch to integrate new features</li> </ul> <p></p>"},{"location":"legacy/installation/","title":"Installation","text":""},{"location":"legacy/installation/#getting-started","title":"Getting Started","text":"<p>The following instructions will help you to setup a clone of the project and run it on your local machine for development. Skip ahead to the deployment section to get a dockerized version up &amp; running.</p>"},{"location":"legacy/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li><code>Python 3.7.0</code> or greater - for running neops.io</li> <li><code>git</code> - to checkout the source code repository</li> <li><code>docker</code> and <code>docker-compose</code> - to run the application containers using docker</li> <li><code>pipenv</code> - for running the backend services</li> <li><code>yarn</code> and <code>node</code> - for running the frontend</li> <li><code>overmind</code> - optional: as mapper to run all services together -&gt; get the latest version here (requires <code>tmux</code>)</li> </ul>"},{"location":"legacy/installation/#development-installation","title":"Development Installation","text":"<p>A step by step examples that tells you how to get a development env running</p> <p>Clone the repository</p> <pre><code>git clone https://github.com/zebbra/neops-core.git\n</code></pre> <p>Start the development containers</p> <pre><code>cd neops-core/docker\ndocker-compose up -d\n</code></pre>"},{"location":"legacy/installation/#backend","title":"Backend","text":"<p>Configure the backend environment (edit the content of <code>.env</code> if necessary)</p> <pre><code>cd neops-core/backend\ncp .env.dist .env\n</code></pre> <p>Create the python virtual enviroment and install the required python libraries</p> <pre><code>cd neops-core/backend\nmkdir .venv\npipenv install\n</code></pre> <p>Apply the database migrations</p> <pre><code>cd neops-core/backend\npipenv run ./manage.py migrate\n</code></pre> <p>Deploy the elastic indexes</p> <pre><code>cd neops-core/backend\npipenv run ./manage.py elastic_index --rebuild\n</code></pre> <p>Create a superuser for the backend</p> <pre><code>cd neops-core/backend\npipenv run ./manage.py createsuperuser\n</code></pre>"},{"location":"legacy/installation/#frontend","title":"Frontend","text":"<p>Install node modules</p> <pre><code>cd neops-core/frontend\nyarn install\n</code></pre> <p>If you run into any problems during the installation, please refer to the Common Problems and Solutions.</p>"},{"location":"legacy/installation/#run-application","title":"Run Application","text":""},{"location":"legacy/installation/#start-with-overmind","title":"Start with overmind","text":"<pre><code>cd neops-core/\novermind start\n</code></pre>"},{"location":"legacy/installation/#start-dedicated","title":"Start dedicated","text":"<p>Frontend</p> <pre><code>cd neops-core/frontend\nyarn dev\n</code></pre> <p>Backend</p> <pre><code>cd neops-core/backend\npipenv run ./manage.py runserver 0.0.0.0:8000\n</code></pre> <p>Workers</p> <pre><code>cd neops-core/backend\npipenv run celery -A neopsapp worker -n w1 -l INFO --concurrency=1\n</code></pre> <p>Beat (task scheduling)</p> <pre><code>cd neops-core/backend\npipenv run celery -A neopsapp beat -l info --scheduler neops.enterprise.celery.cron.scheduler:NeopsCeleryScheduler\n</code></pre>"},{"location":"legacy/installation/#configuration","title":"Configuration","text":"<p>Configuration is handled by the backend with the enviroment variables in <code>backend/.venv</code></p>"},{"location":"legacy/installation/#modules","title":"Modules","text":"<p>neops modules are listed in <code>NEOPS_PLUGINS</code></p> <p>add all modules to load at startup, django settings for those modules are located at <code>neopsapp/settings/neops_plugins</code></p>"},{"location":"legacy/installation/#authentication","title":"Authentication","text":"<p>For authentication an appropriate neops module is required.</p>"},{"location":"legacy/installation/#django-backend-neops_auth_django-default-in-env","title":"Django Backend (neops_auth_django, default in .env)","text":"<p>Users are authenticated against the django default user model.</p> <p>Please use django admin to manage users</p>"},{"location":"legacy/installation/#static-api-key-neops_auth_static_api_key-default-in-env","title":"Static API Key (neops_auth_static_api_key, default in .env)","text":"<p>Used to set static API keys per user</p> <p>Static API keys are set by django manage commands</p> <pre><code>cd neops-core/backend\npipenv run ./manage.py generate_api_key 1 graphiql\n</code></pre> <p>The last 2 parameters are the user id and the name of the app</p>"},{"location":"legacy/installation/#keycloak-neops_auth_keycloak","title":"Keycloak (neops_auth_keycloak)","text":"<p>!&gt; Coming with version 1.0</p>"},{"location":"legacy/installation/#web-frontends","title":"Web Frontends","text":"<ul> <li>neops Frontend - the magic</li> <li>django Admin - access to the database/models</li> <li>graphiql - GraphQL API</li> </ul>"},{"location":"legacy/installation/#neops-application","title":"neops Application","text":"<p>Use the discovery process on the dashboard to add new devices</p>"},{"location":"legacy/installation/#graphiql","title":"GraphiQL","text":"<p>set an API Key first to gain permission to the API</p>"},{"location":"legacy/installation/#deployment","title":"Deployment","text":""},{"location":"legacy/installation/#kubernetes","title":"Kubernetes","text":"<p>!&gt; Coming with version 1.0 Neops can be deployed on a kubernetes cluster using helm. We are standardizing last things under the hood to fulfill our backwards compatibility commitment according to SemVer. Stay tuned!</p>"},{"location":"legacy/installation/#docker-compose","title":"Docker - Compose","text":"<p>Download docker-compose files</p> <pre><code>tar -zxvf neops-docker-compose.tar.gz\n</code></pre>"},{"location":"legacy/installation/#traefik","title":"Traefik","text":"<p>Install Traefik reverse proxy when needed</p> <pre><code>cd traefik\ncp .env.dist .env\n</code></pre> <p>Fill variables in <code>.env</code> with your specific values</p> <p>Create network for Traefik if needed</p> <pre><code>docker network create \\\n    --driver=bridge \\\n    --attachable \\\n    --internal=false \\\n    traefik\n</code></pre> <p>Create self-signed certs</p> <pre><code>echo \"Generating self-signed certificate for localhost\"\nmkdir data\nmkdir data/traefik\nmkdir data/traefik/certs\nopenssl req -new -newkey rsa:2048 -days 365 -nodes -x509 -keyout data/traefik/certs/traefik.key -out data/traefik/certs/traefik.crt  -subj \"/CN=localhost\"\nchmod 700 data/traefik/certs/traefik.key\n</code></pre> <p>Generate .htpasswd for Trafik Dashboard</p> <pre><code>echo \"pw\" | htpasswd -b -i data/traefik/.htpasswd admin\n</code></pre>"},{"location":"legacy/installation/#neops","title":"neops","text":"<p>Create env file and adjust settings</p> <pre><code>cd neops\ncp .env.dist .env\n</code></pre> <p>Fill variables in <code>.env</code> with your specific values</p> <p>Create quay.io login</p> <pre><code>docker login -u=\"zebbra+neops\" -p=\"$PW\" quay.io\n</code></pre> <p>Start containers</p> <pre><code>docker-compose up -d --scale frontend=2 --scale worker=2\n</code></pre> <p>Run db migrations</p> <pre><code>echo \"Running database migrations for neops\"\ndocker-compose exec frontend ./manage.py migrate\n</code></pre> <p>Setup admin</p> <pre><code>Create Django admin user\ndocker-compose exec frontend ./manage.py createsuperuser\n</code></pre>"},{"location":"legacy/installation/#keycloak","title":"Keycloak","text":"<pre><code>cd keycloak\ncp .evn.dist .env\n</code></pre> <p>Fill variables in <code>.env</code> with your specific values</p> <pre><code>docker-compose up -d\n</code></pre> <p>Add neops-realm-export.json as realm in keycloak</p> <p>Setup Realm in Django Admin</p>"},{"location":"legacy/installation/#common-problems-and-solutions","title":"Common Problems and Solutions","text":""},{"location":"legacy/installation/#general","title":"General","text":""},{"location":"legacy/installation/#problem-error-version-in-docker-composeyml-is-unsupported","title":"Problem: <code>ERROR: Version in \"./docker-compose.yml\" is unsupported</code>","text":"<pre><code>$ docker-compose up -d\nERROR: Version in \"./docker-compose.yml\" is unsupported. You might be seeing this error because you're using the wrong Compose file version. Either specify a supported version (e.g \"2.2\" or \"3.3\") and place your service definitions under the `services` key, or omit the `version` key and place your service definitions at the root of the file to use version 1.\nFor more on the Compose file format versions, see https://docs.docker.com/compose/compose-file/\n</code></pre>"},{"location":"legacy/installation/#solution","title":"Solution:","text":"<p>If you get this error messagen when running <code>docker-compose</code>, you have to change the version setting from \"3.7\" to \"3.3\" in the file <code>neops-core/docker/docker-compose.yml</code> on line 2:</p> <pre><code># docker-compose file for development with django and vue.js running directly on the host\nversion: \"3.3\"\n\nservices:\n  redis:\n    image: redis:5-alpine\n            (content skipped)\n</code></pre>"},{"location":"legacy/installation/#problem-error-couldnt-connect-to-docker-daemon-at-httpdockerlocalunixsocket-is-it-running","title":"Problem: <code>ERROR: Couldn't connect to Docker daemon at http+docker://localunixsocket - is it running?</code>","text":"<pre><code>$ docker-compose up -d\nERROR: Couldn't connect to Docker daemon at http+docker://localunixsocket - is it running?\n\nIf it's at a non-standard location, specify the URL with the DOCKER_HOST environment variable.\n</code></pre>"},{"location":"legacy/installation/#solution_1","title":"Solution:","text":"<p>Make sure that the <code>docker</code> is running (example for <code>ubuntu-linux</code>-OS):</p> <pre><code>$ systemctl status docker\n\u25cf docker.service - Docker Application Container Engine\n   Loaded: loaded (/lib/systemd/system/docker.service; disabled; vendor preset:\n   Active: inactive (dead)\n     Docs: https://docs.docker.com\n</code></pre> <p>Start the service if required and afterwards re-run <code>docker-compose</code>:</p> <pre><code>systemctl start docker\n\ncd neops-core/backend\ndocker-compose up -d\n</code></pre>"},{"location":"legacy/installation/#backend_1","title":"Backend","text":""},{"location":"legacy/installation/#problem-warning-python-37-was-not-found-on-your-system","title":"Problem: <code>Warning: Python 3.7 was not found on your system\u2026</code>","text":"<pre><code>$ cd neops-core/backend\n$ pipenv install\nWarning: Python 3.7 was not found on your system\u2026\nYou can specify specific versions of Python with:\n  $ pipenv --python path/to/python\n</code></pre>"},{"location":"legacy/installation/#solution_2","title":"Solution:","text":"<p>Install and specify the correct <code>python</code> version for <code>pipenv</code> (example for <code>ubuntu-linux</code>-OS):</p> <pre><code>sudo apt install python3.7\n\ncd neops-core/backend\npipenv --python /usr/bin/python3.7\n</code></pre>"},{"location":"legacy/installation/#frontend_1","title":"Frontend","text":""},{"location":"legacy/installation/#problem-error-errno-2-no-such-file-or-directory-install","title":"Problem: <code>ERROR: [Errno 2] No such file or directory: 'install'</code>","text":"<pre><code>$ yarn install\n00h00m00s 0/0: : ERROR: [Errno 2] No such file or directory: 'install'\n</code></pre>"},{"location":"legacy/installation/#solution_3","title":"Solution:","text":"<p>By default the commands <code>yarn</code> and <code>cmdtest</code> are the black box testing tools for Unix command line tools cmdtest.</p> <p>Simply remove the existing <code>yarn</code> and <code>cmdtest</code> tools and install the required <code>yarn</code> tool from an external source (example for <code>ubuntu-/debian-linux</code>-OS):</p> <pre><code>sudo apt remove cmdtest\nsudo apt remove yarn\nsudo apt install curl\ncurl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -\necho \"deb https://dl.yarnpkg.com/debian/ stable main\" | sudo tee /etc/apt/sources.list.d/yarn.list\nsudo apt-get update\nsudo apt-get install yarn\n</code></pre>"},{"location":"legacy/installation/#problem-error-yn400-the-engine-node-is-incompatible-with-this-module-expected-version-10","title":"Problem: <code>error yn@4.0.0: The engine \"node\" is incompatible with this module. Expected version \"&gt;=10\"</code>","text":"<pre><code>$ yarn install\nyarn install v1.22.4\n[1/4] Resolving packages...\n[2/4] Fetching packages...\nerror yn@4.0.0: The engine \"node\" is incompatible with this module. Expected version \"&gt;=10\". Got \"8.10.0\"\nerror Found incompatible module.\ninfo Visit https://yarnpkg.com/en/docs/cli/install for documentation about this command.\n</code></pre>"},{"location":"legacy/installation/#solution_4","title":"Solution:","text":"<p>The existing version of <code>node</code> is not recent enough. Update <code>node</code> from an external repository (example for <code>ubuntu-linux</code>-OS):</p> <pre><code>sudo apt update\nsudo apt -y install curl dirmngr apt-transport-https lsb-release ca-certificates\ncurl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -\nsudo apt -y install nodejs\n</code></pre>"},{"location":"legacy/installation/#documentation","title":"Documentation","text":"<p>We are using docsify.js to generate the documentation available here.</p> <p>The source is located in the <code>/docs</code> folder of the project and served using Github Pages.</p> <p>The site consists of several <code>.md</code> files and a single <code>index.html</code>, which loads the markdown files and renders them in the browser.</p> <p>?&gt; NOTE: The projects <code>README.md</code> and <code>CONTRIBUTING.md</code> files are also located in the <code>docs/</code> (and symlinked into the project root directory) to make it available in Github Pages.</p>"},{"location":"legacy/installation/#previewing-the-documentation","title":"Previewing the documentation","text":"<p>You may want to preview the documentation locally using the docsify CLI:</p> <pre><code>$ # install the docsify cli\n$ npm i docsify-cli -g\n\n$ # start the docsify server\n$ docsify serve docs\n\nServing /Users/hw/Projects/neops-core/docs now.\nListening at http://localhost:3000\n</code></pre> <p>Open http://localhost:3000 in your browser to preview the documentation.</p>"},{"location":"legacy/installation/#theming","title":"Theming","text":"<p>The site is using the docsify-themeable theme.</p>"},{"location":"legacy/Appendix/appendix_jinja2/","title":"Jinja2","text":"<p>Jinja2 is a template language for python.</p> <p>It supports a ton of features, we will focus on the basics here.</p> <pre><code>{# comment #}\n\n{{ variable }}\n\n{% if element %}\ndo some content\n{% else %}\nsome content with {{ variable }}\n{% endif %}\n\n{% for element in list %}\n\u2026\u2026do somthing with {{ element }}\n{% endfor%}\n\n{# use filters on elements with | #}\n{{ variable | upper }} {# make a string uppercase\u00a0#}\n{{ variable | regex_replace('foo', 'bar', ignorecase=True) }} {# search foo and replace it with bar\u00a0#}\n{# more filters see below #}\n</code></pre>"},{"location":"legacy/Appendix/appendix_jinja2/#filter","title":"Filter","text":"<p>See this list to checkout all built in filters</p> <p>Additionally we support some custom filters:</p> <ul> <li><code>regex_search</code> _searches a string, returns a list of found elements</li> </ul> <pre><code>{# search for foo in foobar and returns foo #}\n{{ 'foobar' | regex_search('(foo)') }}\n\n{# search for f[a-z] in foobar and returns fo #}\n{{ 'foobar' | regex_search('(f\\w)') }}\n\n{# will return empty if it cannot find a match #}\n{{ 'foo' | regex_search('(foobar)') }}\n\n{# optional parameters are case insensitive search and multiline mode, will return bar#}\n{{ 'foo\\nBAR' | regex_search(\"^bar\", multiline=True, ignorecase=True) }}\n</code></pre> <ul> <li><code>regex_replace</code> search a string and replace it</li> </ul> <pre><code>{# search for foo and replace it with bar #}\n{{ 'foobar' | regex_replace('foo', 'bar') }} {# output: barbar #}\n\n{# ignorecase is supported as well #}\n{{ 'FOObar' | regex_replace('foo', 'bar', ignorecase=True) }} {# output: barbar #}\n\n{# grouping and referencig is supported as well #}\n{{ 'FOObar' | regex_replace('^foo(\\w+)^', '\\\\1\\\\1', ignorecase=True) }} {# output: barbar #}\n</code></pre> <ul> <li>more to come</li> </ul>"},{"location":"legacy/Appendix/appendix_jinja2/#ressources","title":"Ressources","text":"<ul> <li>Jinja2 Documentation</li> <li>and many more are found with your preferred web search engine ;)</li> </ul>"},{"location":"legacy/Appendix/appendix_jsonform/","title":"JSON Form","text":"<p>JSON Schema is used for rendering forms from providers and tasks in the frontend.</p> <p>Example of JSON Form:</p> <pre><code>{\n  \"$id\": \"https://neops.io/schema/example.json\",\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Demo Form JSON Schma\",\n  \"type\": \"object\",\n  \"required\": [\n    \"foo\",\n    \"bar\"\n  ],\n  \"properties\": {\n    \"foo\": {\n      \"title\": \"Foo\",\n      \"type\": \"string\",\n      \"description\": \"Foo rendered as normal input field\"\n    },\n    \"bar\": {\n      \"title\": \"Bar\",\n      \"type\": \"string\",\n      \"description\": \"Bar rendered as editor with syntax highliting for jinja2\",\n      \"x-display\": \"editor-jinja2\"\n    },\n    \"bool\": {\n      \"title\": \"bool\",\n      \"type\": \"boolean\",\n      \"description\": \"boolean is rendered as checkbox\"\n    }\n  }\n}\n</code></pre> <p>Will render this form:</p> <p></p> <p>Fields:</p> <ul> <li><code>$id</code>: global identifier, used if multiple forms are renderd on one page</li> <li><code>$schema</code>: _reference to the json schema for validation (use <code>http://json-schema.org/draft-07/schema#</code>)</li> <li><code>title</code>: form title or on sub-element field title</li> <li><code>type</code>: globally it's always an object (which holds sub-elements in properties), on fields it defines all common data types (string, boolean, number and more)</li> <li><code>required</code>: used for validation, which fields are required</li> <li><code>properties</code>: sub-elements</li> <li><code>x-display</code>: used to affect form rendering</li> </ul> <p>Form more information checkout the ressources below.</p>"},{"location":"legacy/Appendix/appendix_jsonform/#ressources","title":"Ressources","text":"<ul> <li>JSON Form Documentation</li> <li>Datastructure to JSON Form</li> <li>Demo of Vutify JSON Form</li> </ul>"},{"location":"legacy/Appendix/appendix_textfsm/","title":"TextFSM","text":"<p>TextFSM is used to parse semi-formated data.</p> <p>Example of TextFSM Template:</p> <pre><code># Chassis value will be null for single chassis routers.\nValue Filldown Chassis (.cc.?-re.)\nValue Required Slot (\\d+)\nValue State (\\w+)\nValue Temp (\\d+)\nValue CPUTemp (\\d+)\nValue DRAM (\\d+)\nValue Model (\\S+)\n\n# Always starts in 'Start' state.\nStart\n  ^${Chassis}\n  # Record current values and change state.\n  # No record will be output on first pass as 'Slot' is 'Required' but empty.\n  ^Routing Engine status: -&gt; Record RESlot\n\n# A state transition was not strictly necessary but helpful for the example.\nRESlot\n  ^\\s+Slot\\s+${Slot}\n  ^\\s+Current state\\s+${State}\n  ^\\s+Temperature\\s+${Temp} degrees\n  ^\\s+CPU temperature\\s+${CPUTemp} degrees\n  ^\\s+DRAM\\s+${DRAM} MB\n  # Transition back to Start state.\n  ^\\s+Model\\s+${Model} -&gt; Start\n\n# An implicit EOF state outputs the last record.\n</code></pre>"},{"location":"legacy/Appendix/appendix_textfsm/#ressources","title":"Ressources","text":"<ul> <li>TextFSM Documentation</li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base/","title":"neops.core.provider.base.base","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base/#neopsbaseprovider","title":"NeopsBaseProvider","text":"<p>The neops base provider contains all methods and required data processing for a concrete provider. To create a new provider, either extend this NeopsBaseProvider or a concrete provider</p> <p>the neops base provider is inherited from the BaseRunCycle</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base/#json-schema_1","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base/#class-variables","title":"Class variables","text":"<p><pre><code>deprecated: bool\n</code></pre> Indicates if this provider will no longer be supported in the future.</p> <p><pre><code>description: str\n</code></pre> Description String, to give the user an indication of the purpose of this provider</p> <p><pre><code>execution_updater: neops.core.provider.base.execution_updater.ExecutionUpdater\n</code></pre> class to update logs of the current execution (is set by initialization)</p> <p><pre><code>json_schema: Dict\n</code></pre> The <code>json_schema</code> specifies the required input values to instantiate the provider as a task.</p> <p><pre><code>provider_type: neops.core.provider.base.enum.ProviderTypeEnum\n</code></pre> <code>provider_type</code> specifices the provider type, currently we are suppoting vor different types of providers <code>CONFIGURE</code>, <code>FACTS</code>, <code>CHECK</code> and <code>EXECUTE</code>.  The provider type can be used by \"frontend\" applications to have different processes for the provider types. The neops.io frontend the normal handels for example <code>CONFIGURE</code> provider types with a two step run, first dry run then apply.</p> <p><pre><code>result_writer: neops.core.provider.base.base_result_writer.BaseResultWriter\n</code></pre> class to write results (is set by initialization)</p> <p><pre><code>run_input_json_schema: Dict\n</code></pre> \\ The <code>run_input_json_schema</code> specifies the required parameter a provider uses to run, but they must be given on every run and not on task instantination. </p> <p>\\ On a task instantination additional parameters can be requested as input values on a task run. They are merged with the <code>run_input_json_schema</code> values.</p> <p><pre><code>run_on: neops.core.provider.base.enum.RunOnEnum\n</code></pre> <code>run_on</code> specifies on which entity the provider runs, possible values are <code>GLOBAL</code>, <code>GROUP</code>, <code>DEVICE</code>, <code>INTERFACE</code>, <code>CLIENT</code> and <code>GENERIC</code>. On <code>GENERIC</code> the task instance must overwrite the run on value with the <code>init_adjust_run_on</code> method, to specify the excact run_on.</p> <p><pre><code>run_on_all_if_empty: bool\n</code></pre> \\ <code>run_on_all_if_empty</code> specifies if all elements of a given <code>run_on</code> type are selected when a empty list is given as <code>execute_on</code> parameter on the <code>run</code> method.</p> <p><pre><code>run_on_result: Union[neops.core.provider.base.enum.RunOnEnum,\u00a0NoneType]\n</code></pre> <code>run_on_result</code> specifies for which entity the result is written.  Normally this is the same as the <code>run_on</code> value and if <code>run_on_result</code> is <code>None</code> then the <code>run_on</code> value is used. </p> <p>Example for different values of <code>run_on</code> and <code>run_on_result</code>: If you build a provider which get facts for interfaces, but those facts are only collectable per device (you always get the facts for all interfaces on this device).  In such a case it could make sense to set <code>run_on</code> to <code>DEVICE</code> and <code>run_on_result</code> to <code>INTERFACE</code>, then you got the result per interface and it's visible for which interfaces the facts are collected.</p> <p><pre><code>run_on_strict: bool\n</code></pre> \\ <code>run_on_strict</code> specifies if we accept loose input entities for the <code>execute_on_type</code> and <code>execute_on</code> parameters on the <code>run</code> method.</p> <p>Example: if <code>run_on_strict</code> is false and <code>run_on</code> is INTERFACE, then we accept a list of devices on the <code>run</code> method and will resolve all interfaces on those devices where the task is executed. This could be a problem for some cases, e.g if you have a configure provider where you prefere to know the exact entities. Because of that <code>run_on_strict</code> is true per default.</p> <p><pre><code>short_description: str\n</code></pre> A Short description for list views or others.</p> <p><pre><code>success_message: str\n</code></pre> The <code>success_message</code> is used if no message is set on the results object and if a task is successfully executed on an entity.</p> <p><pre><code>validate_input: bool\n</code></pre> \\ <code>validate_input</code> specifies if the parameters on the <code>run</code> method should by verified against the json schema definitions of the task itself, the provider <code>run_input_json_schema</code> and <code>json_schema</code>.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base/#methods","title":"Methods","text":"<p><pre><code>add_markdown_helptext(self,md_content:\u00a0neops.core.libs.helptext.markdown_content.MarkDownContent) -&gt; NoneType\n</code></pre> Add documentation elements to the generated provider documentations to give a better insight how this provider should work.</p> <p>\\ On the base provider we add only the json schema of the task instantiation to give a better overview which parameters are required for this provider.</p> <p>\\ param md_content: MarkDownContent of the current documentation of this element.</p> <p><pre><code>add_nornir_processors(self) -&gt; List[nornir.core.processor.Processor]\n</code></pre> Add additional Nornir Processors, for more information see https://nornir.readthedocs.io/en/v2.5.0/tutorials/intro/processors.html</p> <p><pre><code>init_adjust_run_on(self,execute_on:\u00a0Union[List[int],\u00a0NoneType]\u00a0=\u00a0None,execute_on_type:\u00a0Union[neops.core.provider.base.enum.RunOnEnum,\u00a0NoneType]\u00a0=\u00a0None,dry_run:\u00a0Union[bool,\u00a0NoneType]\u00a0=\u00a0None,task_input_kwargs:\u00a0Union[Dict[Any,\u00a0Any],\u00a0NoneType]\u00a0=\u00a0None,search_query:\u00a0str\u00a0=\u00a0'',task_kwargs:\u00a0Union[Dict[Any,\u00a0Any],\u00a0NoneType]\u00a0=\u00a0None,**kwargs) -&gt; NoneType\n</code></pre> Method to overwrite <code>run_on</code>, <code>run_on_strict</code> and <code>run_on_result</code> values on provider initialization based on the given paremeters of the run and the task itself.</p> <p>For example used by generic providers.</p> <p>\\ param execute_on: List of element IDs to run on \\ param execute_on_type: Type of those IDs (GROUP, DEVICE, INTERFACE, CLIENT) \\ param dry_run: Indicates if no configuration changes should be made \\ param task_input_kwargs: Run input arguments \\ param task_kwargs: Task arguments</p> <p><pre><code>init_before_run(self,task_input_kwargs:\u00a0Dict,execute_on:\u00a0List\u00a0=\u00a0None,execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum\u00a0=\u00a0device,dry_run:\u00a0bool\u00a0=\u00a0True,search_query:\u00a0str\u00a0=\u00a0'',**kwargs) -&gt; NoneType\n</code></pre> Initialization of all elements before the task runs. This methots initializes all result objects.</p> <p>\\ param task_input_kwargs: Run input arguments \\ param execute_on: List of element IDs to run on \\ param execute_on_type: Type of those IDs (GROUP, DEVICE, INTERFACE, CLIENT) \\ param dry_run: Indicates if no configuration changes should be made \\ param search_query: An optional search query to limit the entities to run on (not yet supported)</p> <p><pre><code>init_without_run(self,**kwargs) -&gt; NoneType\n</code></pre> <pre><code>print_results(self) -&gt; \n</code></pre> prints the current result set.</p> <p><pre><code>run(self,task_input_kwargs:\u00a0Dict,execute_on:\u00a0List\u00a0=\u00a0None,execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum\u00a0=\u00a0device,dry_run:\u00a0bool\u00a0=\u00a0True,search_query:\u00a0str\u00a0=\u00a0'',**kwargs) -&gt; NoneType\n</code></pre> Runs the provider based on the initialized task.</p> <p>\\ param task_input_kwargs: Run input arguments \\ param execute_on: List of element IDs to run on \\ param execute_on_type: Type of those IDs (GROUP, DEVICE, INTERFACE, CLIENT) \\ param dry_run: Indicates if no configuration changes should be made \\ param search_query: An optional search query to limit the entities to run on (not yet supported)</p> <p><pre><code>update_do(self,do:\u00a0str,append:\u00a0bool\u00a0=\u00a0True) -&gt; NoneType\n</code></pre> Wrapper method to the execution updater <code>update_do</code> method</p> <p>\\ param do: string what is to do \\ param append: decides if the do string is appended or replaced</p> <p><pre><code>update_done(self,done:\u00a0str,append:\u00a0bool\u00a0=\u00a0True) -&gt; NoneType\n</code></pre> <pre><code>update_log(self,log:\u00a0str,append:\u00a0bool\u00a0=\u00a0True) -&gt; NoneType\n</code></pre> Wrapper method to the execution updater <code>update_log</code> method</p> <p>\\ param log: the log string \\ param append: decides if the log string is appended or replaced</p> <p><pre><code>validate_schema(self,task_kwargs:\u00a0Dict\u00a0=\u00a0None) -&gt; NoneType\n</code></pre> \\ Validates if the parameters of the task</p> <p>\\ param task_kwargs: task parameters</p> <p><pre><code>write_results(self,subtask_finish:\u00a0bool\u00a0=\u00a0False,task_finish:\u00a0bool\u00a0=\u00a0False) -&gt; NoneType\n</code></pre> Write the result states to the database.</p> <p>\\ param subtask_finish: is true if i am a subtasks (pre/post run task) and the task itself is finished \\ param task_finish: is true if all subtasks and the task itself is finished</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base/#functions","title":"Functions","text":"<p><pre><code>inherit_json_schema(json_schema:\u00a0Dict\u00a0=\u00a0None) -&gt; Dict\n</code></pre> Merges JSON Schemas: If this method is called on one of the classes children, then super().json_schema resolves, else we do a pseudo merge. \\ param json_schema: \\ return: Dict of merged JSON Schema</p> <p><pre><code>init_from_task_model(neops_task:\u00a0neops.core.models.neops_task.NeopsTask,nr:\u00a0nornir.core.Nornir\u00a0=\u00a0None,**kwargs) -&gt; neops.core.provider.base.base.NeopsBaseProvider\n</code></pre> Initialization of the task by a the given <code>NeopsTask</code> model and the <code>Nornir</code> inventory.</p> <p>\\ param neops_task: Neops Task Model \\ param nr: Nornir Inventory</p> <p>\\ return: Instance of the provider/task itself</p> <p><pre><code>merge_run_input_json_schema(json_schema:\u00a0Dict\u00a0=\u00a0None) -&gt; \n</code></pre> Merges the JSON Schemas of instanciated task and those of this provider</p> <p>\\ param json_schema: \\ return: merged JSON Schema</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_check/","title":"neops.core.provider.base.base_check","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_check/#neopscheckbaseprovider","title":"NeopsCheckBaseProvider","text":"<p>This Provider is inherited from the <code>NeopsBaseProvider</code>, it brings additional functionality to handle checks.</p> <p>Every Task based on this provider needs a check key where the check result is stored in the database per element.</p> <p>For providers inherits from this provider the check results are written automatically based on the result set of the pre- and run methods per element. It supports check results, boolean values and handels exceptions.</p> <p>This provider should be the base for check providers. So if you create a new check provider with, either extend this <code>NeopsCheckBaseProvider</code> or a concrete check provider</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_check/#check-result","title":"Check Result","text":"<p>see below</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_check/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_check/#check-base-provider","title":"Check Base Provider","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_check/#properties","title":"Properties","text":"<ul> <li><code>check_key</code> (string): Set the key where the check is saved.</li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_check/#class-variables","title":"Class variables","text":"<p><pre><code>based_on_checks\n</code></pre> If the check result is based on other checks, specify them for trancing.</p> <p><pre><code>check_for\n</code></pre> The entity where the checks are for can be different from the <code>run_on</code>, so specify if required otherwise we will use the <code>run_on</code> value.</p> <p><pre><code>related_facts\n</code></pre> Specify on which facts the check result is based on. This enables tracing when and how the values are stored in neops.io</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_check/#methods","title":"Methods","text":"<p><pre><code>process_client_results(self,results:\u00a0List[neops.core.provider.base.result.coupled_provider_result_types.ProviderClientResult]\u00a0=\u00a0None) -&gt; NoneType\n</code></pre> <code>process_client_results</code> is called at the end of the run cycle. It stores the client results as checks to the database if the <code>check_for</code> variable is set to <code>CLIENT</code></p> <p><pre><code>process_device_group_results(self,results:\u00a0List[neops.core.provider.base.result.coupled_provider_result_types.ProviderDeviceGroupResult]\u00a0=\u00a0None) -&gt; NoneType\n</code></pre> <code>process_device_group_results</code> is called at the end of the run cycle. It stores the device group results as checks to the database if the <code>check_for</code> variable is set to <code>GROUP</code></p> <p><pre><code>process_device_results(self,results:\u00a0List[neops.core.provider.base.result.coupled_provider_result_types.ProviderDeviceResult]\u00a0=\u00a0None) -&gt; NoneType\n</code></pre> <code>process_device_results</code> is called at the end of the run cycle. It stores the device results as checks to the database if the <code>check_for</code> variable is set to <code>DEVICE</code></p> <p><pre><code>process_global_result(self,result:\u00a0nornir.core.task.Result\u00a0=\u00a0None) -&gt; NoneType\n</code></pre> Global checks are currently not supported..</p> <p><pre><code>process_interface_results(self,results:\u00a0List[neops.core.provider.base.result.coupled_provider_result_types.ProviderInterfaceResult]\u00a0=\u00a0None) -&gt; NoneType\n</code></pre> <code>process_interface_results</code> is called at the end of the run cycle. It stores the interface results as checks to the database if the <code>check_for</code> variable is set to <code>INTERFACE</code></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_check/#neopscheckresult","title":"NeopsCheckResult","text":"<p>A check result contains the result, metrics and a reason for the result of the check.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_check/#class-variables_1","title":"Class variables","text":"<p><pre><code>metrics: Dict\n</code></pre> additional metrics of this checks, this is a flexible data structure to be used in custom frontends</p> <p><pre><code>reason: str\n</code></pre> the reason for this result</p> <p><pre><code>result: neops.core.models.check.CheckResultEnum\n</code></pre> * OK: the check was executed successfully and fullfills the requirements * NOK: the check was executed successfull but does not fullfill the requirements * FAILED: there was an error to perform this check</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_configure/","title":"neops.core.provider.base.base_configure","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_configure/#neopsconfigurebaseprovider","title":"NeopsConfigureBaseProvider","text":"<p>This provider extends the NeopsBaseProvider by the functionality of storing configurations (on device results) to the device it self by different apply methods.</p> <p>This provider should be the base for configuration providers. So if you create a new configuration provider with, either extend this <code>NeopsConfigureBaseProvider</code> or a concrete configuration provider</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_configure/#global-base-configure-parameters","title":"Global Base Configure Parameters","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_configure/#apply-method","title":"Apply Method","text":"<p>The apply method descripbes how the configuration is written to the device.</p> <ul> <li><code>cli</code>: the configuration is applied directly in the configration mode</li> <li><code>scp</code>: the configuration is copied (with scp) as a file to the device and applied with an merge operation</li> <li><code>scp-startup</code>: the configuration is copied (with scp) as a file to the device and written to the start up configuration</li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_configure/#slow-devices","title":"Slow Devices","text":"<p>With the <code>slow_device</code> parameter you can specify a delay factor to wait a longer time on responses from             slow devices</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_configure/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_configure/#configure-base-provider","title":"Configure Base Provider","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_configure/#properties","title":"Properties","text":"<ul> <li> <p><code>apply</code> (string): Method how to apply the configuration, over cli or copy with scp and merge. Must be one of: <code>['scp', 'cli', 'scp-startup']</code>.</p> </li> <li> <p><code>slow_device</code> (integer): Add a factor for longer wait times for heavy loaded devices. Default: <code>0</code>.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_configure/#methods","title":"Methods","text":"<p><pre><code>run_on_nornir_device(self,task:\u00a0nornir.core.task.Task,nornir_device_result:\u00a0neops.core.provider.base.result.coupled_provider_result_types.ProviderNornirDeviceResult,dry_run:\u00a0bool\u00a0=\u00a0True,**kwargs) -&gt; str\n</code></pre> <code>run_on_nornir_device</code> is called by the run cycle.</p> <p>It takes the result from the <code>pre_run_on_nornir_device</code> and from every related device with the <code>pre_run_on_device</code> and <code>run_on_device</code> methods and writes the configuration to the device.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_facts/","title":"neops.core.provider.base.base_facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_facts/#neopsfactsbaseprovider","title":"NeopsFactsBaseProvider","text":"<p>This Provider is inherited from the <code>NeopsBaseProvider</code>, it brings additional functionality to handle facts (flexible data structures per entity).</p> <p>Every task based on this provider needs a facts key where the facts result is stored in the database per element.</p> <p>For providers inherits from this provider the facts results are written automatically based on the result set of the pre- and run methods per element. It supports data structures of any kind as long as they are compatible to JSON.</p> <p>This provider should be the base for fact providers. So if you create a new fact provider with, either extend this <code>NeopsFactsBaseProvider</code> or a concrete fact provider</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_facts/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_facts/#facts-base-provider","title":"Facts Base Provider","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_facts/#properties","title":"Properties","text":"<ul> <li><code>facts_key</code> (string): Set the key where the facts are saved.</li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_facts/#class-variables","title":"Class variables","text":"<p><pre><code>facts_for\n</code></pre> The entity where the facts are for, can be different from the <code>run_on</code>, so specify if required otherwise we will use the <code>run_on</code> value.</p> <p>This provider supports that facts are written for different entities, so use facts for as a list.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_facts/#methods","title":"Methods","text":"<p><pre><code>process_client_results(self,results:\u00a0List[neops.core.provider.base.result.coupled_provider_result_types.ProviderClientResult]) -&gt; NoneType\n</code></pre> <code>process_client_results</code> is called at the end of the run cycle. It stores the client results data structures as facts to the database if the <code>facts_for</code> variable is set to <code>CLIENT</code></p> <p><pre><code>process_device_group_results(self,results:\u00a0List[neops.core.provider.base.result.coupled_provider_result_types.ProviderDeviceGroupResult]) -&gt; NoneType\n</code></pre> <code>process_device_group_results</code> is called at the end of the run cycle. It stores the device group results data structures as facts to the database if the <code>facts_for</code> variable is set to <code>GROUP</code></p> <p><pre><code>process_device_results(self,results:\u00a0List[neops.core.provider.base.result.coupled_provider_result_types.ProviderDeviceResult]) -&gt; NoneType\n</code></pre> <code>process_device_results</code> is called at the end of the run cycle. It stores the device results data structures as facts to the database if the <code>facts_for</code> variable is set to <code>DEVICE</code></p> <p><pre><code>process_global_result(self,result:\u00a0neops.core.provider.base.result.provider_result.ProviderResult) -&gt; NoneType\n</code></pre> <code>process_global_result</code> is called at the end of the run cycle. It stores the global results data structures as facts to the database if the <code>facts_for</code> variable is set to <code>GLOBAL</code></p> <p><pre><code>process_interface_results(self,results:\u00a0List[neops.core.provider.base.result.coupled_provider_result_types.ProviderInterfaceResult]) -&gt; NoneType\n</code></pre> <code>process_interface_results</code> is called at the end of the run cycle. It stores the interface results data structures as facts to the database if the <code>facts_for</code> variable is set to <code>INTERFACE</code></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_process_result_cycle/","title":"neops.core.provider.base.base_process_result_cycle","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_process_result_cycle/#baseprocessresultcycle","title":"BaseProcessResultCycle","text":"<p>This class describes the methods provided to process different result objects.</p> <p>They are used for example by the facts or check base providers to save the results to the database.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_process_result_cycle/#methods","title":"Methods","text":"<p><pre><code>process_client_result(self,result:\u00a0neops.core.provider.base.result.coupled_provider_result_types.ProviderClientResult) -&gt; NoneType\n</code></pre> This method is called for every client result (does not matters if ran on interface or on group).</p> <p>\\ param result (ProviderClientResult): client result object.</p> <p><pre><code>process_client_results(self,results:\u00a0List[neops.core.provider.base.result.coupled_provider_result_types.ProviderClientResult]) -&gt; NoneType\n</code></pre> This method is called once with a list of all client results (does not matters if ran on interface or on group).</p> <p>\\ param results (List[ProviderClientResult]): list of client result objects.</p> <p><pre><code>process_device_group_result(self,result:\u00a0neops.core.provider.base.result.coupled_provider_result_types.ProviderDeviceGroupResult) -&gt; NoneType\n</code></pre> This method is called for every device group result.</p> <p>\\ param result (ProviderDeviceGroupResult): device group result object.</p> <p><pre><code>process_device_group_results(self,results:\u00a0List[neops.core.provider.base.result.coupled_provider_result_types.ProviderDeviceGroupResult]) -&gt; NoneType\n</code></pre> This method is called once with a list of all device group results.</p> <p>\\ param results (List[ProviderDeviceGroupResult]): list of device group result objects.</p> <p><pre><code>process_device_result(self,result:\u00a0neops.core.provider.base.result.coupled_provider_result_types.ProviderDeviceResult) -&gt; NoneType\n</code></pre> This method is called for every device result.</p> <p>\\ param result (ProviderDeviceResult): device result object.</p> <p><pre><code>process_device_results(self,results:\u00a0List[neops.core.provider.base.result.coupled_provider_result_types.ProviderDeviceResult]) -&gt; NoneType\n</code></pre> This method is called once with a list of all device results.</p> <p>\\ param results (List[ProviderDeviceResult]): list of device result objects.</p> <p><pre><code>process_global_result(self,result:\u00a0neops.core.provider.base.result.provider_result.ProviderResult) -&gt; NoneType\n</code></pre> This method is called once for the global result.</p> <p>\\ param result (ProviderResult): global result object.</p> <p><pre><code>process_interface_result(self,result:\u00a0neops.core.provider.base.result.coupled_provider_result_types.ProviderInterfaceResult) -&gt; NoneType\n</code></pre> This method is called for every interface result.</p> <p>\\ param result (ProviderInterfaceResult): interface result object.</p> <p><pre><code>process_interface_results(self,results:\u00a0List[neops.core.provider.base.result.coupled_provider_result_types.ProviderInterfaceResult]) -&gt; NoneType\n</code></pre> This method is called once with a list of all interface results.</p> <p>\\ param results (List[ProviderInterfaceResult]): list of interface result objects.</p> <p><pre><code>process_nornir_device_result(self,result:\u00a0neops.core.provider.base.result.coupled_provider_result_types.ProviderNornirDeviceResult) -&gt; NoneType\n</code></pre> This method is called for every nornir device result.</p> <p>\\ param result (ProviderNornirDeviceResult): nornir device result object.</p> <p><pre><code>process_nornir_device_results(self,results:\u00a0List[neops.core.provider.base.result.coupled_provider_result_types.ProviderNornirDeviceResult]) -&gt; NoneType\n</code></pre> This method is called once with a list of all nornir device results.</p> <p>\\ param results (List[ProviderNornirDeviceResult]): list of nornir device result objects.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_result_writer/","title":"neops.core.provider.base.base_result_writer","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_result_writer/#baseresultwriter","title":"BaseResultWriter","text":"<p>Writes/updates the result object</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_result_writer/#methods","title":"Methods","text":"<p><pre><code>write_results(self,results:\u00a0neops.core.provider.base.result.provider_result_composite.ProviderResultsComposite,execution_id:\u00a0int,run_on_result:\u00a0neops.core.provider.base.enum.RunOnEnum,success_message:\u00a0str\u00a0=\u00a0'',subtask_finish:\u00a0bool\u00a0=\u00a0False,task_finish:\u00a0bool\u00a0=\u00a0False,neops_task_id:\u00a0Union[int,\u00a0NoneType]\u00a0=\u00a0None,granularity:\u00a0int\u00a0=\u00a05) -&gt; NoneType\n</code></pre> This method is called on the beginning and the end of a task or a subtask (pre- and post run tasks).</p> <p>It updates the result set in the databae for the relevant entities on which the task is executed and informs the user over the progress.</p> <p>\\ param results (ProviderResultsComposite): All results of the run cycle methods \\ param execution_id (int): id of the current execution \\ param run_on_result (RunOnEnum): for which entity the results should be stored \\ param success_message (str, optional): message to be set for a successfully processed element \\ param subtask_finish (bool, optional): identifies if a subtask (pre- or post run task is finished) \\ param task_finish (bool, optional): identifies if the main task is finished \\ param neops_task_id (Optional[int], optional): the id of the task whichone ran \\ param granularity (int, optional): describes the importance of a task result (values from 1-10, higher values are more important results, default is 5)</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_run_arguments/","title":"neops.core.provider.base.base_run_arguments","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_run_arguments/#neopsproviderrunarguments","title":"NeopsProviderRunArguments","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_run_cycle/","title":"neops.core.provider.base.base_run_cycle","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_run_cycle/#baseruncycle","title":"BaseRunCycle","text":"<p>Description of the base run cycle for a provider</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_run_cycle/#access-to-task-and-input-arguments","title":"Access to Task and Input Arguments","text":"<p>To access to the task arguments and to the given input values use the following arguments passed to every run cycle methhod</p> <p>Task Arguments <pre><code>task_option = task_kwargs.get('task_option')\n</code></pre> Run Input Arguments <pre><code>input_option = task_input_kwargs.get('input_option')\n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_run_cycle/#class-variables","title":"Class variables","text":"<pre><code>name: str\n</code></pre>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.base_run_cycle/#methods","title":"Methods","text":"<p><pre><code>add_markdown_helptext(self,md_content:\u00a0neops.core.libs.helptext.markdown_content.MarkDownContent) -&gt; NoneType\n</code></pre> Add documentation elements to the generated provider documentations to give a better insight how this provider should work.</p> <p>\\ param md_content: MarkDownContent of the current documentation of this element.</p> <p><pre><code>pre_run_global(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,dry_run:\u00a0bool,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],search_query:\u00a0str,task_kwargs:\u00a0Dict[Any,\u00a0Any],result=neops.core.provider.base.result.provider_global_result.ProviderGlobalResult,**kwargs) -&gt; Any\n</code></pre> This method is executed as the 1. step of a run cycle. It's called once on a global basis.</p> <p>\\ param execute_on (List[int]): ids on which elements the task is executed \\ param execute_on_type (RunOnEnum): on which entity type the task is executed \\ param dry_run (bool): defines if no changes should be applied (especially for configuration tasks) \\ param task_input_kwargs (Dict[Any, Any]): additional input arguments per task \\ param search_query (str): search query to limit elements to run on \\ param task_kwargs (Dict[Any, Any]): task arguments \\ param result ([ProviderGlobalResult], optional): empty ProviderGlobalResult to be updated</p> <p>\\ return: results or exceptions are stored in a ProviderGlobalResult object</p> <p><pre><code>pre_run_on_client_of_interface(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,dry_run:\u00a0bool,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],search_query:\u00a0str,task_kwargs:\u00a0Dict[Any,\u00a0Any],task:\u00a0nornir.core.task.Task,nornir_device_id:\u00a0int,device_id:\u00a0int,interface_id:\u00a0int,client_id:\u00a0int,client_result=neops.core.provider.base.result.coupled_provider_result_types.ProviderClientResult,**kwargs) -&gt; Any\n</code></pre> This method is executed as the 7. step of a run cycle. It's called once per related (execute_on and execute_on_type) clients connected to the interfaces of step 6.</p> <p>\\ param execute_on (List[int]): ids on which elements the task is executed \\ param execute_on_type (RunOnEnum): on which entity type the task is executed \\ param dry_run (bool): defines if no changes should be applied (especially for configuration tasks) \\ param task_input_kwargs (Dict[Any, Any]): additional input arguments per task \\ param search_query (str): search query to limit elements to run on \\ param task_kwargs (Dict[Any, Any]): task arguments \\ param task (Task): nornir Task object \\ param nornir_device_id (int): id of the related nornir device \\ param device_id (int): id of the related device \\ param interface_id (int): id of the connected interface \\ param client_id (int): id of the current client \\ param client_result ([ProviderClientResult], optional): empty ProviderClientResult to be updated (with a reference to the related parent objects)</p> <p>\\ return: results or exceptions are stored in a ProviderClientResult object</p> <p><pre><code>pre_run_on_client_of_location(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,dry_run:\u00a0bool,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],search_query:\u00a0str,task_kwargs:\u00a0Dict[Any,\u00a0Any],location_id:\u00a0int,client_id:\u00a0int,client_result=neops.core.provider.base.result.coupled_provider_result_types.ProviderClientResult,**kwargs) -&gt; Any\n</code></pre> This method is executed as the 3. step of a run cycle. It's called once per related (execute_on and execute_on_type) client on the location of the 2. step.</p> <p>\\ param execute_on (List[int]): ids on which elements the task is executed \\ param execute_on_type (RunOnEnum): on which entity type the task is executed \\ param dry_run (bool): defines if no changes should be applied (especially for configuration tasks) \\ param task_input_kwargs (Dict[Any, Any]): additional input arguments per task \\ param search_query (str): search query to limit elements to run on \\ param task_kwargs (Dict[Any, Any]): task arguments \\ param location_id (int): id of the related location/device group \\ param client_id (int): id of the current client \\ param client_result ([ProviderClientResult], optional): empty ProviderClientResult to be updated (with a reference to the related parent objects)</p> <p>\\ return: results or exceptions are stored in a ProviderClientResult object</p> <p><pre><code>pre_run_on_device(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,dry_run:\u00a0bool,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],search_query:\u00a0str,task_kwargs:\u00a0Dict[Any,\u00a0Any],task:\u00a0nornir.core.task.Task,nornir_device_id:\u00a0int,device_id:\u00a0int,device_result=neops.core.provider.base.result.coupled_provider_result_types.ProviderDeviceResult,**kwargs) -&gt; Any\n</code></pre> This method is executed as the 5. step of a run cycle. It's called once per related (execute_on and execute_on_type) device.</p> <p>\\ param execute_on (List[int]): ids on which elements the task is executed \\ param execute_on_type (RunOnEnum): on which entity type the task is executed \\ param dry_run (bool): defines if no changes should be applied (especially for configuration tasks) \\ param task_input_kwargs (Dict[Any, Any]): additional input arguments per task \\ param search_query (str): search query to limit elements to run on \\ param task_kwargs (Dict[Any, Any]): task arguments \\ param task (Task): nornir Task object \\ param nornir_device_id (int): id of the related nornir device \\ param device_id (int): id of the current device \\ param device_result ([ProviderDeviceResult], optional): empty ProviderDeviceResult to be updated (with a reference to the related parent objects)</p> <p>\\ return: results or exceptions are stored in a ProviderDeviceResult object</p> <p><pre><code>pre_run_on_device_group(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,dry_run:\u00a0bool,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],search_query:\u00a0str,task_kwargs:\u00a0Dict[Any,\u00a0Any],device_group_id:\u00a0int,device_group_result=neops.core.provider.base.result.coupled_provider_result_types.ProviderDeviceGroupResult,**kwargs) -&gt; Any\n</code></pre> This method is executed as the 2. step of a run cycle. It's called once per related (execute_on and execute_on_type) device group.</p> <p>\\ param execute_on (List[int]): ids on which elements the task is executed \\ param execute_on_type (RunOnEnum): on which entity type the task is executed \\ param dry_run (bool): defines if no changes should be applied (especially for configuration tasks) \\ param task_input_kwargs (Dict[Any, Any]): additional input arguments per task \\ param search_query (str): search query to limit elements to run on \\ param task_kwargs (Dict[Any, Any]): task arguments \\ param device_group_id (int): id of the current device group \\ param device_group_result ([ProviderDeviceGroupResult], optional): empty ProviderDeviceGroupResult to be updated</p> <p>\\ return: results or exceptions are stored in a ProviderDeviceGroupResult object</p> <p><pre><code>pre_run_on_interface(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,dry_run:\u00a0bool,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],search_query:\u00a0str,task_kwargs:\u00a0Dict[Any,\u00a0Any],task:\u00a0nornir.core.task.Task,nornir_device_id:\u00a0int,device_id:\u00a0int,interface_id:\u00a0int,interface_result=neops.core.provider.base.result.coupled_provider_result_types.ProviderInterfaceResult,**kwargs) -&gt; Any\n</code></pre> This method is executed as the 6. step of a run cycle. It's called once per related (execute_on and execute_on_type) interface.</p> <p>\\ param execute_on (List[int]): ids on which elements the task is executed \\ param execute_on_type (RunOnEnum): on which entity type the task is executed \\ param dry_run (bool): defines if no changes should be applied (especially for configuration tasks) \\ param task_input_kwargs (Dict[Any, Any]): additional input arguments per task \\ param search_query (str): search query to limit elements to run on \\ param task_kwargs (Dict[Any, Any]): task arguments \\ param task (Task): nornir Task object \\ param nornir_device_id (int): id of the related nornir device \\ param device_id (int): id of the related device \\ param interface_id (int): id of the current interface \\ param interface_result ([ProviderInterfaceResult], optional): empty ProviderInterfaceResult to be updated (with a reference to the related parent objects)</p> <p>\\ return: results or exceptions are stored in a ProviderInterfaceResult object</p> <p><pre><code>pre_run_on_nornir_device(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,dry_run:\u00a0bool,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],search_query:\u00a0str,task_kwargs:\u00a0Dict[Any,\u00a0Any],task:\u00a0nornir.core.task.Task,nornir_device_id:\u00a0int,nornir_device_result=neops.core.provider.base.result.coupled_provider_result_types.ProviderNornirDeviceResult,**kwargs) -&gt; Any\n</code></pre> This method is executed as the 4. step of a run cycle. It's called once per related (execute_on and execute_on_type) nornir_device.</p> <p>A nornir_device is in the most cases the same as a device, except you have controller configured devices, then it's the controller itself or in otherwords where configurations are applied.</p> <p>Nornir devices are executed and threaded with nornir task runner.</p> <p>\\ param execute_on (List[int]): ids on which elements the task is executed \\ param execute_on_type (RunOnEnum): on which entity type the task is executed \\ param dry_run (bool): defines if no changes should be applied (especially for configuration tasks) \\ param task_input_kwargs (Dict[Any, Any]): additional input arguments per task \\ param search_query (str): search query to limit elements to run on \\ param task_kwargs (Dict[Any, Any]): task arguments \\ param task (Task): nornir Task object \\ param nornir_device_id (int): id of the current nornir device \\ param nornir_device_result ([ProviderNornirDeviceResult], optional): empty ProviderNornirDeviceResult to be updated (with a reference to the related parent objects)</p> <p>\\ return: results or exceptions are stored in a ProviderNornirDeviceResult object</p> <p><pre><code>run_global(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,dry_run:\u00a0bool,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],search_query:\u00a0str,task_kwargs:\u00a0Dict[Any,\u00a0Any],result=neops.core.provider.base.result.provider_global_result.ProviderGlobalResult,**kwargs) -&gt; Any\n</code></pre> This method is executed as the 14. step of a run cycle. It's called once on a global basis.</p> <p>\\ param execute_on (List[int]): ids on which elements the task is executed \\ param execute_on_type (RunOnEnum): on which entity type the task is executed \\ param dry_run (bool): defines if no changes should be applied (especially for configuration tasks) \\ param task_input_kwargs (Dict[Any, Any]): additional input arguments per task \\ param search_query (str): search query to limit elements to run on \\ param task_kwargs (Dict[Any, Any]): task arguments \\ param result ([ProviderGlobalResult], optional): ProviderGlobalResult with the result of step 1 \\ return: results or exceptions are stored in a ProviderGlobalResult object</p> <p><pre><code>run_on_client_of_interface(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,dry_run:\u00a0bool,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],search_query:\u00a0str,task_kwargs:\u00a0Dict[Any,\u00a0Any],task:\u00a0nornir.core.task.Task,nornir_device_id:\u00a0int,device_id:\u00a0int,interface_id:\u00a0int,client_id:\u00a0int,client_result:\u00a0neops.core.provider.base.result.coupled_provider_result_types.ProviderClientResult,**kwargs) -&gt; Any\n</code></pre> This method is executed as the 8. step of a run cycle. It's called once per related (execute_on and execute_on_type) clients connected to the interfaces of step 9.</p> <p>\\ param execute_on (List[int]): ids on which elements the task is executed \\ param execute_on_type (RunOnEnum): on which entity type the task is executed \\ param dry_run (bool): defines if no changes should be applied (especially for configuration tasks) \\ param task_input_kwargs (Dict[Any, Any]): additional input arguments per task \\ param search_query (str): search query to limit elements to run on \\ param task_kwargs (Dict[Any, Any]): task arguments \\ param task (Task): nornir Task object \\ param nornir_device_id (int): id of the related nornir device \\ param device_id (int): id of the related device \\ param interface_id (int): id of the connected interface \\ param client_id (int): id of the current client \\ param client_result ([ProviderClientResult], optional): ProviderClientResult with the results of step 7</p> <p>\\ return: results or exceptions are stored in a ProviderClientResult object</p> <p><pre><code>run_on_client_of_location(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,dry_run:\u00a0bool,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],search_query:\u00a0str,task_kwargs:\u00a0Dict[Any,\u00a0Any],location_id:\u00a0int,client_id:\u00a0int,client_result=neops.core.provider.base.result.coupled_provider_result_types.ProviderClientResult,**kwargs) -&gt; Any\n</code></pre> This method is executed as the 12. step of a run cycle. It's called once per related (execute_on and execute_on_type) client on the location of the 2. step.</p> <p>\\ param execute_on (List[int]): ids on which elements the task is executed \\ param execute_on_type (RunOnEnum): on which entity type the task is executed \\ param dry_run (bool): defines if no changes should be applied (especially for configuration tasks) \\ param task_input_kwargs (Dict[Any, Any]): additional input arguments per task \\ param search_query (str): search query to limit elements to run on \\ param task_kwargs (Dict[Any, Any]): task arguments \\ param location_id (int): id of the related location/device group \\ param client_id (int): id of the current client \\ param client_result ([ProviderClientResult], optional): ProviderClientResult with the result of step 3</p> <p>\\ return: results or exceptions are stored in a ProviderClientResult object</p> <p><pre><code>run_on_device(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,dry_run:\u00a0bool,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],search_query:\u00a0str,task_kwargs:\u00a0Dict[Any,\u00a0Any],task:\u00a0nornir.core.task.Task,nornir_device_id:\u00a0int,device_id:\u00a0int,device_result:\u00a0neops.core.provider.base.result.coupled_provider_result_types.ProviderDeviceResult,**kwargs) -&gt; Any\n</code></pre> This method is executed as the 10. step of a run cycle. It's called once per related (execute_on and execute_on_type) device.</p> <p>\\ param execute_on (List[int]): ids on which elements the task is executed \\ param execute_on_type (RunOnEnum): on which entity type the task is executed \\ param dry_run (bool): defines if no changes should be applied (especially for configuration tasks) \\ param task_input_kwargs (Dict[Any, Any]): additional input arguments per task \\ param search_query (str): search query to limit elements to run on \\ param task_kwargs (Dict[Any, Any]): task arguments \\ param task (Task): nornir Task object \\ param nornir_device_id (int): id of the related nornir device \\ param device_id (int): id of the current device \\ param device_result ([ProviderDeviceResult], optional): ProviderDeviceResult with the result of step 5</p> <p>\\ return: results or exceptions are stored in a ProviderDeviceResult object</p> <p><pre><code>run_on_device_group(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,dry_run:\u00a0bool,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],search_query:\u00a0str,task_kwargs:\u00a0Dict[Any,\u00a0Any],device_group_id:\u00a0int,device_group_result=neops.core.provider.base.result.coupled_provider_result_types.ProviderDeviceGroupResult,**kwargs) -&gt; Any\n</code></pre> This method is executed as the 13. step of a run cycle. It's called once per related (execute_on and execute_on_type) device group.</p> <p>\\ param execute_on (List[int]): ids on which elements the task is executed \\ param execute_on_type (RunOnEnum): on which entity type the task is executed \\ param dry_run (bool): defines if no changes should be applied (especially for configuration tasks) \\ param task_input_kwargs (Dict[Any, Any]): additional input arguments per task \\ param search_query (str): search query to limit elements to run on \\ param task_kwargs (Dict[Any, Any]): task arguments \\ param device_group_id (int): id of the current device group \\ param device_group_result ([ProviderDeviceGroupResult], optional): ProviderDeviceGroupResult with the result of step 2</p> <p>\\ return: results or exceptions are stored in a ProviderDeviceGroupResult object</p> <p><pre><code>run_on_interface(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,dry_run:\u00a0bool,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],search_query:\u00a0str,task_kwargs:\u00a0Dict[Any,\u00a0Any],task:\u00a0nornir.core.task.Task,nornir_device_id:\u00a0int,device_id:\u00a0int,interface_id:\u00a0int,interface_result=neops.core.provider.base.result.coupled_provider_result_types.ProviderInterfaceResult,**kwargs) -&gt; Any\n</code></pre> This method is executed as the 9. step of a run cycle. It's called once per related (execute_on and execute_on_type) interface.</p> <p>\\ param execute_on (List[int]): ids on which elements the task is executed \\ param execute_on_type (RunOnEnum): on which entity type the task is executed \\ param dry_run (bool): defines if no changes should be applied (especially for configuration tasks) \\ param task_input_kwargs (Dict[Any, Any]): additional input arguments per task \\ param search_query (str): search query to limit elements to run on \\ param task_kwargs (Dict[Any, Any]): task arguments \\ param task (Task): nornir Task object \\ param nornir_device_id (int): id of the related nornir device \\ param device_id (int): id of the related device \\ param interface_id (int): id of the current interface \\ param interface_result ([ProviderInterfaceResult], optional): ProviderInterfaceResult with the result of step 6</p> <p>\\ return: results or exceptions are stored in a ProviderInterfaceResult object</p> <p><pre><code>run_on_nornir_device(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,dry_run:\u00a0bool,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],search_query:\u00a0str,task_kwargs:\u00a0Dict[Any,\u00a0Any],task:\u00a0nornir.core.task.Task,nornir_device_id:\u00a0int,nornir_device_result=neops.core.provider.base.result.coupled_provider_result_types.ProviderNornirDeviceResult,**kwargs) -&gt; Any\n</code></pre> This method is executed as the 11. step of a run cycle. It's called once per related (execute_on and execute_on_type) nornir_device.</p> <p>A nornir_device is in the most cases the same as a device, except you have controller configured devices, then it's the controller itself or in otherwords where configurations are applied.</p> <p>Nornir devices are executed and threaded with nornir task runner.</p> <p>\\ param execute_on (List[int]): ids on which elements the task is executed \\ param execute_on_type (RunOnEnum): on which entity type the task is executed \\ param dry_run (bool): defines if no changes should be applied (especially for configuration tasks) \\ param task_input_kwargs (Dict[Any, Any]): additional input arguments per task \\ param search_query (str): search query to limit elements to run on \\ param task_kwargs (Dict[Any, Any]): task arguments \\ param task (Task): nornir Task object \\ param nornir_device_id (int): id of the current nornir device \\ param nornir_device_result ([ProviderNornirDeviceResult], optional): ProviderNornirDeviceResult with the result of step 4</p> <p>\\ return: results or exceptions are stored in a ProviderNornirDeviceResult object</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.element_resolver/","title":"neops.core.provider.base.element_resolver","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.element_resolver/#elementresolver","title":"ElementResolver","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.element_resolver/#methods","title":"Methods","text":"<p><pre><code>resolve_execute(self,resolve_on:\u00a0ResolveOn,execute_on:\u00a0List,execute_on_type:\u00a0RunOnEnum,invert_filter:\u00a0bool\u00a0=\u00a0False) -&gt; Union[List[int],\u00a0NoneType]\n</code></pre> This method calls the right resolver based on resolve_on \\ param resolve_on: \\ param execute_on: \\ param execute_on_type: \\ param invert_filter: \\ return:</p> <p><pre><code>resolve_execute_on_clients(self,execute_on:\u00a0List,execute_on_type:\u00a0RunOnEnum,invert_filter:\u00a0bool\u00a0=\u00a0False) -&gt; List[int]\n</code></pre> <pre><code>resolve_execute_on_clients_of_group(self,execute_on:\u00a0List,execute_on_type:\u00a0RunOnEnum,invert_filter:\u00a0bool\u00a0=\u00a0False) -&gt; List[int]\n</code></pre> <pre><code>resolve_execute_on_clients_of_interface(self,execute_on:\u00a0List,execute_on_type:\u00a0RunOnEnum,invert_filter:\u00a0bool\u00a0=\u00a0False) -&gt; List[int]\n</code></pre> <pre><code>resolve_execute_on_devices(self,execute_on:\u00a0List,execute_on_type:\u00a0RunOnEnum,invert_filter:\u00a0bool\u00a0=\u00a0False) -&gt; List[int]\n</code></pre> <pre><code>resolve_execute_on_groups(self,execute_on:\u00a0List,execute_on_type:\u00a0RunOnEnum,invert_filter:\u00a0bool\u00a0=\u00a0False) -&gt; Union[List[int],\u00a0NoneType]\n</code></pre> <pre><code>resolve_execute_on_interfaces(self,execute_on:\u00a0List,execute_on_type:\u00a0RunOnEnum,invert_filter:\u00a0bool\u00a0=\u00a0False) -&gt; List[int]\n</code></pre> <pre><code>resolve_execute_on_nornir_devices(self,execute_on:\u00a0List,execute_on_type:\u00a0RunOnEnum,invert_filter:\u00a0bool\u00a0=\u00a0False) -&gt; List[int]\n</code></pre> <pre><code>resolve_related_elements(self,resolve_by:\u00a0ResolveBy,element_id:\u00a0int,execute_on:\u00a0List,resolve_related_on:\u00a0RunOnEnum\u00a0=\u00a0None) -&gt; Union[List[int],\u00a0NoneType]\n</code></pre> This method calls the right resolver based on resolve_by \\ param resolve_by: \\ param element_id: \\ param execute_on: \\ param resolve_related_on: \\ return:</p> <p><pre><code>resolve_related_elements_by_client(self,client_id:\u00a0int,execute_on:\u00a0List,resolve_related_on:\u00a0RunOnEnum\u00a0=\u00a0None) -&gt; List[int]\n</code></pre> <pre><code>resolve_related_elements_by_device(self,device_id:\u00a0int,execute_on:\u00a0List,resolve_related_on:\u00a0RunOnEnum\u00a0=\u00a0None) -&gt; List\n</code></pre> <pre><code>resolve_related_elements_by_device_group(self,device_group_id:\u00a0int,execute_on:\u00a0List,resolve_related_on:\u00a0RunOnEnum\u00a0=\u00a0None) -&gt; List[int]\n</code></pre> <pre><code>resolve_related_elements_by_interface(self,interface_id:\u00a0int,execute_on:\u00a0List,resolve_related_on:\u00a0RunOnEnum\u00a0=\u00a0None) -&gt; List[int]\n</code></pre> <pre><code>resolve_related_elements_by_nornir_device(self,nornir_device_id:\u00a0int,execute_on:\u00a0List,resolve_related_on:\u00a0RunOnEnum\u00a0=\u00a0None) -&gt; List[int]\n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.element_resolver/#resolveby","title":"ResolveBy","text":"<p>An enumeration.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.element_resolver/#class-variables","title":"Class variables","text":"<p><pre><code>CLIENT\n</code></pre> <pre><code>DEVICE\n</code></pre> <pre><code>DEVICE_GROUP\n</code></pre> <pre><code>INTERFACE\n</code></pre> <pre><code>NORNIR_DEVICE\n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.element_resolver/#functions","title":"Functions","text":"<pre><code>resolve(key:\u00a0str) -&gt; neops.core.provider.base.element_resolver.ResolveBy\n</code></pre>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.element_resolver/#resolveon","title":"ResolveOn","text":"<p>An enumeration.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.element_resolver/#class-variables_1","title":"Class variables","text":"<p><pre><code>CLIENTS\n</code></pre> <pre><code>DEVICES\n</code></pre> <pre><code>GROUPS\n</code></pre> <pre><code>INTERFACES\n</code></pre> <pre><code>NORNIR_DEVICES\n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.element_resolver/#functions_1","title":"Functions","text":"<pre><code>resolve(key:\u00a0str) -&gt; neops.core.provider.base.element_resolver.ResolveOn\n</code></pre>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.enum/","title":"neops.core.provider.base.enum","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.enum/#expandelement","title":"ExpandElement","text":"<p>An enumeration.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.enum/#class-variables","title":"Class variables","text":"<p><pre><code>CLIENTS_ON_INTERFACES\n</code></pre> <pre><code>CLIENTS_ON_LOCATIONS\n</code></pre> <pre><code>DEVICES\n</code></pre> <pre><code>GROUPS\n</code></pre> <pre><code>INTERFACES\n</code></pre> <pre><code>NORNIR_DEVICES\n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.enum/#functions","title":"Functions","text":"<p><pre><code>intersects(list1:\u00a0List[ExpandElement],list2:\u00a0List[ExpandElement]) -&gt; \n</code></pre> <pre><code>resolve(key:\u00a0str) -&gt; neops.core.provider.base.enum.ExpandElement\n</code></pre> <pre><code>resolve_for(key:\u00a0str,selection:\u00a0List[ExpandElement]) -&gt; Union[neops.core.provider.base.enum.ExpandElement,\u00a0NoneType]\n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.enum/#providertypeenum","title":"ProviderTypeEnum","text":"<p>An enumeration.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.enum/#class-variables_1","title":"Class variables","text":"<p><pre><code>CHECK\n</code></pre> <pre><code>CONFIGURE\n</code></pre> <pre><code>EXECUTE\n</code></pre> <pre><code>FACTS\n</code></pre> <pre><code>NONE\n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.enum/#instance-variables","title":"Instance variables","text":"<p><pre><code>is_check\n</code></pre> <pre><code>is_configure\n</code></pre> <pre><code>is_execute\n</code></pre> <pre><code>is_facts\n</code></pre> <pre><code>is_none\n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.enum/#functions_1","title":"Functions","text":"<pre><code>resolve(key:\u00a0str) -&gt; neops.core.provider.base.enum.ProviderTypeEnum\n</code></pre>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.enum/#runonenum","title":"RunOnEnum","text":"<p>An enumeration.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.enum/#class-variables_2","title":"Class variables","text":"<p><pre><code>CLIENT\n</code></pre> <pre><code>DEVICE\n</code></pre> <pre><code>GENERIC\n</code></pre> <pre><code>GLOBAL\n</code></pre> <pre><code>GROUP\n</code></pre> <pre><code>INTERFACE\n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.enum/#instance-variables_1","title":"Instance variables","text":"<p><pre><code>is_client\n</code></pre> <pre><code>is_device\n</code></pre> <pre><code>is_generic\n</code></pre> <pre><code>is_global\n</code></pre> <pre><code>is_group\n</code></pre> <pre><code>is_interface\n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.enum/#functions_2","title":"Functions","text":"<p><pre><code>resolve(key:\u00a0str) -&gt; neops.core.provider.base.enum.RunOnEnum\n</code></pre> <pre><code>resolve_for(key:\u00a0str,selection:\u00a0List[RunOnEnum]) -&gt; Union[neops.core.provider.base.enum.RunOnEnum,\u00a0NoneType]\n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.execution_updater/","title":"neops.core.provider.base.execution_updater","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.execution_updater/#executionupdater","title":"ExecutionUpdater","text":"<p>Updates a particular execution</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.execution_updater/#methods","title":"Methods","text":"<p><pre><code>update_do(self,do:\u00a0str,append:\u00a0bool\u00a0=\u00a0True) -&gt; NoneType\n</code></pre> <pre><code>update_done(self,done:\u00a0str,append:\u00a0bool\u00a0=\u00a0True) -&gt; NoneType\n</code></pre> <pre><code>update_log(self,log:\u00a0str,append:\u00a0bool\u00a0=\u00a0True) -&gt; NoneType\n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base/","title":"neops.core.provider.base","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.coupled_provider_result_types/","title":"neops.core.provider.base.result.coupled_provider_result_types","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.coupled_provider_result_types/#providerclientresult","title":"ProviderClientResult","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.coupled_provider_result_types/#methods","title":"Methods","text":"<p><pre><code>get_ran_on(self) -&gt; Union[neops.core.provider.base.enum.RunOnEnum,\u00a0NoneType]\n</code></pre> <pre><code>set_interface(self,interface:\u00a0ProviderInterfaceResult,reverse:\u00a0bool\u00a0=\u00a0True) -&gt; NoneType\n</code></pre> <pre><code>set_location(self,location:\u00a0ProviderDeviceGroupResult,reverse:\u00a0bool\u00a0=\u00a0True) -&gt; NoneType\n</code></pre> <pre><code>write_result(self,execution_id:\u00a0int,neops_task_id:\u00a0Optional[int]\u00a0=\u00a0None,granularity:\u00a0int\u00a0=\u00a05) -&gt; \n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.coupled_provider_result_types/#providerdevicegroupresult","title":"ProviderDeviceGroupResult","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.coupled_provider_result_types/#methods_1","title":"Methods","text":"<p><pre><code>add_client(self,client:\u00a0ProviderClientResult,reverse:\u00a0bool\u00a0=\u00a0True) -&gt; NoneType\n</code></pre> <pre><code>add_device(self,device:\u00a0ProviderDeviceResult,reverse:\u00a0bool\u00a0=\u00a0True) -&gt; NoneType\n</code></pre> <pre><code>get_ran_on(self) -&gt; Union[neops.core.provider.base.enum.RunOnEnum,\u00a0NoneType]\n</code></pre> <pre><code>write_result(self,execution_id:\u00a0int,neops_task_id:\u00a0Optional[int]\u00a0=\u00a0None,granularity:\u00a0int\u00a0=\u00a05) -&gt; \n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.coupled_provider_result_types/#providerdeviceresult","title":"ProviderDeviceResult","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.coupled_provider_result_types/#methods_2","title":"Methods","text":"<p><pre><code>add_device_group(self,device_group:\u00a0\"'ProviderDeviceGroupResult'\",reverse:\u00a0bool\u00a0=\u00a0True) -&gt; NoneType\n</code></pre> <pre><code>add_interface(self,interface:\u00a0ProviderInterfaceResult,reverse:\u00a0bool\u00a0=\u00a0True) -&gt; NoneType\n</code></pre> <pre><code>get_ran_on(self) -&gt; Union[neops.core.provider.base.enum.RunOnEnum,\u00a0NoneType]\n</code></pre> <pre><code>set_nornir_device(self,nornir_device:\u00a0\"'ProviderNornirDeviceResult'\",reverse:\u00a0bool\u00a0=\u00a0True) -&gt; NoneType\n</code></pre> <pre><code>write_result(self,execution_id:\u00a0int,neops_task_id:\u00a0Optional[int]\u00a0=\u00a0None,granularity:\u00a0int\u00a0=\u00a05) -&gt; \n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.coupled_provider_result_types/#providerinterfaceresult","title":"ProviderInterfaceResult","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.coupled_provider_result_types/#methods_3","title":"Methods","text":"<p><pre><code>add_client(self,client:\u00a0\"'ProviderClientResult'\",reverse:\u00a0bool\u00a0=\u00a0True) -&gt; NoneType\n</code></pre> <pre><code>get_ran_on(self) -&gt; Union[neops.core.provider.base.enum.RunOnEnum,\u00a0NoneType]\n</code></pre> <pre><code>set_device(self,device:\u00a0\"'ProviderDeviceResult'\",reverse:\u00a0bool\u00a0=\u00a0True) -&gt; NoneType\n</code></pre> <pre><code>write_result(self,execution_id:\u00a0int,neops_task_id:\u00a0Optional[int]\u00a0=\u00a0None,granularity:\u00a0int\u00a0=\u00a05) -&gt; \n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.coupled_provider_result_types/#providernornirdeviceresult","title":"ProviderNornirDeviceResult","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.coupled_provider_result_types/#methods_4","title":"Methods","text":"<p><pre><code>add_device(self,device:\u00a0ProviderDeviceResult,reverse:\u00a0bool\u00a0=\u00a0True) -&gt; NoneType\n</code></pre> <pre><code>get_ran_on(self) -&gt; Union[neops.core.provider.base.enum.RunOnEnum,\u00a0NoneType]\n</code></pre> <pre><code>write_result(self,execution_id:\u00a0int,neops_task_id:\u00a0Optional[int]\u00a0=\u00a0None,granularity:\u00a0int\u00a0=\u00a05) -&gt; \n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.exception/","title":"neops.core.provider.base.result.exception","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.exception.related_result_failed/","title":"neops.core.provider.base.result.exception.related_result_failed","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.exception.related_result_failed/#relatedresultfailed","title":"RelatedResultFailed","text":"<p>Common base class for all non-exit exceptions.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result/","title":"neops.core.provider.base.result","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.provider_global_result/","title":"neops.core.provider.base.result.provider_global_result","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.provider_global_result/#providerglobalresult","title":"ProviderGlobalResult","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.provider_global_result/#methods","title":"Methods","text":"<p><pre><code>get_ran_on(self) -&gt; Union[neops.core.provider.base.enum.RunOnEnum,\u00a0NoneType]\n</code></pre> <pre><code>write_result(self,execution_id:\u00a0int,neops_task_id:\u00a0Union[int,\u00a0NoneType]\u00a0=\u00a0None,granularity:\u00a0int\u00a0=\u00a05) -&gt; \n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.provider_result/","title":"neops.core.provider.base.result.provider_result","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.provider_result/#providerresult","title":"ProviderResult","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.provider_result/#methods","title":"Methods","text":"<p><pre><code>add_child(self,child:\u00a0ProviderResult,reverse:\u00a0bool\u00a0=\u00a0True) -&gt; NoneType\n</code></pre> <pre><code>add_parent(self,parent:\u00a0ProviderResult,reverse:\u00a0bool\u00a0=\u00a0True) -&gt; NoneType\n</code></pre> <pre><code>child_has_state(self,state:\u00a0neops.core.models.execution_result.ExecutionResultStateEnum) -&gt; bool\n</code></pre> <pre><code>child_has_state_recursive(self,state:\u00a0neops.core.models.execution_result.ExecutionResultStateEnum) -&gt; bool\n</code></pre> <pre><code>child_is_failed(self) -&gt; bool\n</code></pre> <pre><code>child_is_failed_recursive(self) -&gt; bool\n</code></pre> <pre><code>get_ran_on(self) -&gt; Union[neops.core.provider.base.enum.RunOnEnum,\u00a0NoneType]\n</code></pre> <pre><code>is_failed(self) -&gt; bool\n</code></pre> <pre><code>parent_is_failed(self) -&gt; bool\n</code></pre> <pre><code>related_is_failed(self) -&gt; bool\n</code></pre> <pre><code>set_children_as_failed(self) -&gt; NoneType\n</code></pre> <pre><code>set_parents_as_failed(self) -&gt; NoneType\n</code></pre> <pre><code>update(self,pre_run_result:\u00a0Any\u00a0=\u00a0None,result:\u00a0Any\u00a0=\u00a0None,message:\u00a0str\u00a0=\u00a0None,exception:\u00a0Exception\u00a0=\u00a0None,failed:\u00a0bool\u00a0=\u00a0None,state:\u00a0Union[neops.core.models.execution_result.ExecutionResultStateEnum,\u00a0neops.core.models.device_execution.DeviceExecutionStateEnum]\u00a0=\u00a0None,from_object:\u00a0ProviderResult\u00a0=\u00a0None,reset_result:\u00a0bool\u00a0=\u00a0False,set_children_as_failed:\u00a0bool\u00a0=\u00a0True,set_parents_as_failed:\u00a0bool\u00a0=\u00a0False,overwrite:\u00a0bool\u00a0=\u00a0True) -&gt; NoneType\n</code></pre> <pre><code>write_result(self,execution_id:\u00a0int) -&gt; \n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.provider_result_composite/","title":"neops.core.provider.base.result.provider_result_composite","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.provider_result_composite/#providerresultscomposite","title":"ProviderResultsComposite","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.base.result.provider_result_composite/#methods","title":"Methods","text":"<p><pre><code>get_client_result(self,client_id:\u00a0int) -&gt; neops.core.provider.base.result.coupled_provider_result_types.ProviderClientResult\n</code></pre> <pre><code>get_device_group_result(self,device_group_id:\u00a0int) -&gt; neops.core.provider.base.result.coupled_provider_result_types.ProviderDeviceGroupResult\n</code></pre> <pre><code>get_device_result(self,device_id:\u00a0int) -&gt; neops.core.provider.base.result.coupled_provider_result_types.ProviderDeviceResult\n</code></pre> <pre><code>get_interface_result(self,interface_id:\u00a0int) -&gt; neops.core.provider.base.result.coupled_provider_result_types.ProviderInterfaceResult\n</code></pre> <pre><code>get_nornir_device_result(self,nornir_device_id:\u00a0int) -&gt; neops.core.provider.base.result.coupled_provider_result_types.ProviderNornirDeviceResult\n</code></pre> <pre><code>load_from_db(self,execution_id:\u00a0int,pre_check_as_failed:\u00a0bool\u00a0=\u00a0False,post_check_as_failed:\u00a0bool\u00a0=\u00a0False) -&gt; \n</code></pre> <pre><code>merge(self,merge_object:\u00a0ProviderResultsComposite) -&gt; NoneType\n</code></pre> <pre><code>reset_result(self) -&gt; NoneType\n</code></pre> <pre><code>set_client_interface_relation(self,client_id:\u00a0int,interface_id:\u00a0int) -&gt; NoneType\n</code></pre> <pre><code>set_client_location_relation(self,client_id:\u00a0int,location_id:\u00a0int) -&gt; NoneType\n</code></pre> <pre><code>set_device_device_group_relation(self,device_id:\u00a0int,device_group_id:\u00a0int) -&gt; NoneType\n</code></pre> <pre><code>set_device_nornir_device_relation(self,device_id:\u00a0int,nornir_device_id:\u00a0int) -&gt; NoneType\n</code></pre> <pre><code>set_interface_device_relation(self,interface_id:\u00a0int,device_id:\u00a0int) -&gt; NoneType\n</code></pre> <pre><code>update_client_result(self,client_id:\u00a0int,**kwargs) -&gt; NoneType\n</code></pre> <pre><code>update_device_group_result(self,device_group_id:\u00a0int,**kwargs) -&gt; NoneType\n</code></pre> <pre><code>update_device_result(self,device_id:\u00a0int,**kwargs) -&gt; NoneType\n</code></pre> <pre><code>update_interface_result(self,interface_id:\u00a0int,**kwargs) -&gt; NoneType\n</code></pre> <pre><code>update_nornir_device_result(self,nornir_device_id:\u00a0int,**kwargs) -&gt; NoneType\n</code></pre> <pre><code>upsert_client_result(self,client_id:\u00a0int,**kwargs) -&gt; NoneType\n</code></pre> <pre><code>upsert_device_group_result(self,device_group_id:\u00a0int,**kwargs) -&gt; NoneType\n</code></pre> <pre><code>upsert_device_result(self,device_id:\u00a0int,**kwargs) -&gt; NoneType\n</code></pre> <pre><code>upsert_interface_result(self,interface_id:\u00a0int,**kwargs) -&gt; NoneType\n</code></pre> <pre><code>upsert_nornir_device_result(self,nornir_device_id:\u00a0int,**kwargs) -&gt; NoneType\n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_check/","title":"neops.core.provider.deprecated.device_check","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_check/#devicecheckprovider","title":"DeviceCheckProvider","text":"<p>This Provider is inherited from the <code>NeopsBaseProvider</code>, it brings additional functionality to handle checks.</p> <p>Every Task based on this provider needs a check key where the check result is stored in the database per element.</p> <p>For providers inherits from this provider the check results are written automatically based on the result set of the pre- and run methods per element. It supports check results, boolean values and handels exceptions.</p> <p>This provider should be the base for check providers. So if you create a new check provider with, either extend this <code>NeopsCheckBaseProvider</code> or a concrete check provider</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_check/#check-result","title":"Check Result","text":"<p>see below</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_check/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_check/#check-facts-with-regex","title":"Check Facts with Regex","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_check/#properties","title":"Properties","text":"<ul> <li> <p><code>check_key</code> (string): Set the key where the check is saved.</p> </li> <li> <p><code>checks</code> (array): This description is used as a help message.</p> </li> <li> <p>Items (object)</p> <ul> <li><code>element</code> (object)</li> </ul> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_interface_textfsm_facts/","title":"neops.core.provider.deprecated.device_interface_textfsm_facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_interface_textfsm_facts/#deviceinterfacetextfsmfactsprovider","title":"DeviceInterfaceTextFSMFactsProvider","text":"<p>This Provider is inherited from the <code>NeopsBaseProvider</code>, it brings additional functionality to handle facts (flexible data structures per entity).</p> <p>Every task based on this provider needs a facts key where the facts result is stored in the database per element.</p> <p>For providers inherits from this provider the facts results are written automatically based on the result set of the pre- and run methods per element. It supports data structures of any kind as long as they are compatible to JSON.</p> <p>This provider should be the base for fact providers. So if you create a new fact provider with, either extend this <code>NeopsFactsBaseProvider</code> or a concrete fact provider</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_interface_textfsm_facts/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_interface_textfsm_facts/#add-structured-command-to-facts","title":"Add Structured Command to Facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_interface_textfsm_facts/#properties","title":"Properties","text":"<ul> <li> <p><code>facts_key</code> (string): Set the key where the facts are saved.</p> </li> <li> <p><code>command</code> (string): Show command to convert to structured data.</p> </li> <li> <p><code>interface_name</code> (string): Add a JMES Path to the interface name of the result for the mapping. Default: ``.</p> </li> <li> <p><code>textfsm</code> (string): TextFSM Template to parse the show output.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_regex_facts/","title":"neops.core.provider.deprecated.device_regex_facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_regex_facts/#deviceregexfactsprovider","title":"DeviceRegexFactsProvider","text":"<p>This Provider is inherited from the <code>NeopsBaseProvider</code>, it brings additional functionality to handle facts (flexible data structures per entity).</p> <p>Every task based on this provider needs a facts key where the facts result is stored in the database per element.</p> <p>For providers inherits from this provider the facts results are written automatically based on the result set of the pre- and run methods per element. It supports data structures of any kind as long as they are compatible to JSON.</p> <p>This provider should be the base for fact providers. So if you create a new fact provider with, either extend this <code>NeopsFactsBaseProvider</code> or a concrete fact provider</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_regex_facts/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_regex_facts/#add-structured-command-to-facts","title":"Add Structured Command to Facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_regex_facts/#properties","title":"Properties","text":"<ul> <li> <p><code>facts_key</code> (string): Set the key where the facts are saved.</p> </li> <li> <p><code>command</code> (string): Show command to convert to structured data.</p> </li> <li> <p><code>regex</code> (string): Regular expression.</p> </li> <li> <p><code>regex_ignore</code> (boolean): Regular expression case sensitive or not. Default: <code>False</code>.</p> </li> <li> <p><code>regex_multi</code> (boolean): Regular expression multiline or not. Default: <code>False</code>.</p> </li> <li> <p><code>regex_dotall</code> (boolean): Dot stands for special characters as well. Default: <code>False</code>.</p> </li> <li> <p><code>match_keys</code> (array): map the matches to keys,                 if multiple (for OR in regex without match use (?:expr1|expr2) ).</p> </li> <li> <p>Items (string)</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_test_provider/","title":"neops.core.provider.deprecated.device_test_provider","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_test_provider/#module-functions","title":"Module functions","text":"<p><pre><code>test_sub_sub_task(task:\u00a0nornir.core.task.Task,res:\u00a0str) -&gt; nornir.core.task.Result\n</code></pre> <pre><code>test_sub_task(task:\u00a0nornir.core.task.Task,res:\u00a0str) -&gt; nornir.core.task.Result\n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_test_provider/#devicetestprovider","title":"DeviceTestProvider","text":"<p>The neops base provider contains all methods and required data processing for a concrete provider. To create a new provider, either extend this NeopsBaseProvider or a concrete provider</p> <p>the neops base provider is inherited from the BaseRunCycle</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_test_provider/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_test_provider/#demo-form-json-schema","title":"Demo Form JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_test_provider/#properties","title":"Properties","text":"<ul> <li> <p><code>foo</code> (string): Foo rendered as normal input field.</p> </li> <li> <p><code>bar</code> (string): Bar rendered as editor with syntax highlighting for jinja2.</p> </li> <li> <p><code>bool</code> (boolean): boolean is rendered as checkbox. Default: <code>False</code>.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_textfsm_facts/","title":"neops.core.provider.deprecated.device_textfsm_facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_textfsm_facts/#devicetextfsmfactsprovider","title":"DeviceTextFSMFactsProvider","text":"<p>This Provider is inherited from the <code>NeopsBaseProvider</code>, it brings additional functionality to handle facts (flexible data structures per entity).</p> <p>Every task based on this provider needs a facts key where the facts result is stored in the database per element.</p> <p>For providers inherits from this provider the facts results are written automatically based on the result set of the pre- and run methods per element. It supports data structures of any kind as long as they are compatible to JSON.</p> <p>This provider should be the base for fact providers. So if you create a new fact provider with, either extend this <code>NeopsFactsBaseProvider</code> or a concrete fact provider</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_textfsm_facts/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_textfsm_facts/#add-structured-command-to-facts","title":"Add Structured Command to Facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_textfsm_facts/#properties","title":"Properties","text":"<ul> <li> <p><code>facts_key</code> (string): Set the key where the facts are saved.</p> </li> <li> <p><code>command</code> (string): Show command to convert to structured data.</p> </li> <li> <p><code>textfsm</code> (string): TextFSM Template to parse the show output.</p> </li> <li> <p><code>slow_device</code> (integer): Add a factor for longer wait times for heavy loaded devices. Default: <code>0</code>.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_textfsm_facts_by_param/","title":"neops.core.provider.deprecated.device_textfsm_facts_by_param","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_textfsm_facts_by_param/#devicetextfsmfactsbyparamprovider","title":"DeviceTextFSMFactsByParamProvider","text":"<p>This Provider is inherited from the <code>NeopsBaseProvider</code>, it brings additional functionality to handle facts (flexible data structures per entity).</p> <p>Every task based on this provider needs a facts key where the facts result is stored in the database per element.</p> <p>For providers inherits from this provider the facts results are written automatically based on the result set of the pre- and run methods per element. It supports data structures of any kind as long as they are compatible to JSON.</p> <p>This provider should be the base for fact providers. So if you create a new fact provider with, either extend this <code>NeopsFactsBaseProvider</code> or a concrete fact provider</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_textfsm_facts_by_param/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_textfsm_facts_by_param/#add-structured-command-to-facts","title":"Add Structured Command to Facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_textfsm_facts_by_param/#properties","title":"Properties","text":"<ul> <li> <p><code>facts_key</code> (string): Set the key where the facts are saved.</p> </li> <li> <p><code>command</code> (string): Show command to convert to structured data.</p> </li> <li> <p><code>jmes_param</code> (string): Add a JMES Path that can be uses as Param in the command.                 The $1 will be replaced by the content.                 For executing and parsing the command we expect a list.                 (access to device facts use facts. as initial key). Default: ``.</p> </li> <li> <p><code>textfsm</code> (string): TextFSM Template to parse the show output.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_textfsm_ntc_facts/","title":"neops.core.provider.deprecated.device_textfsm_ntc_facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_textfsm_ntc_facts/#devicetextfsmntcfactsprovider","title":"DeviceTextFSMNTCFactsProvider","text":"<p>This Provider is inherited from the <code>NeopsBaseProvider</code>, it brings additional functionality to handle facts (flexible data structures per entity).</p> <p>Every task based on this provider needs a facts key where the facts result is stored in the database per element.</p> <p>For providers inherits from this provider the facts results are written automatically based on the result set of the pre- and run methods per element. It supports data structures of any kind as long as they are compatible to JSON.</p> <p>This provider should be the base for fact providers. So if you create a new fact provider with, either extend this <code>NeopsFactsBaseProvider</code> or a concrete fact provider</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_textfsm_ntc_facts/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_textfsm_ntc_facts/#add-structured-command-to-facts","title":"Add Structured Command to Facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.device_textfsm_ntc_facts/#properties","title":"Properties","text":"<ul> <li> <p><code>facts_key</code> (string): Set the key where the facts are saved.</p> </li> <li> <p><code>command</code> (string): Show command to convert to structured data.</p> </li> <li> <p><code>slow_device</code> (integer): Add a factor for longer wait times for heavy loaded devices. Default: <code>0</code>.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.global_from_excel/","title":"neops.core.provider.deprecated.global_from_excel","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.global_from_excel/#globalfromexcel","title":"GlobalFromExcel","text":"<p>The neops base provider contains all methods and required data processing for a concrete provider. To create a new provider, either extend this NeopsBaseProvider or a concrete provider</p> <p>the neops base provider is inherited from the BaseRunCycle</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.global_from_excel/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.global_from_excel/#excel-to-process-tasks","title":"Excel to Process Tasks","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.global_from_excel/#properties","title":"Properties","text":"<ul> <li> <p><code>header_num</code> (number): On which line in the sheet is the header placed. Default: <code>1</code>.</p> </li> <li> <p><code>tasks</code> (array): This description is used as a help message.</p> </li> <li> <p>Items (object)</p> <ul> <li> <p><code>hosts_template</code> (string): parse excel content (given as excel var to jinja) and create a list of hosts to run the process on. Default: ``.</p> </li> <li> <p><code>task_id</code> (number): Default: <code>0</code>.</p> </li> <li> <p><code>task_template</code> (string): parse excel content (given as excel var to jinja) and provide the data structure for the task. Default: ``.</p> </li> </ul> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.global_test_provider/","title":"neops.core.provider.deprecated.global_test_provider","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.global_test_provider/#globaltestprovider","title":"GlobalTestProvider","text":"<p>The neops base provider contains all methods and required data processing for a concrete provider. To create a new provider, either extend this NeopsBaseProvider or a concrete provider</p> <p>the neops base provider is inherited from the BaseRunCycle</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.global_test_provider/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.global_test_provider/#device-test-provider","title":"Device Test Provider","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.global_test_provider/#properties","title":"Properties","text":"<ul> <li><code>foo</code> (string): Foo Task Form Value.</li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.group_test_provider/","title":"neops.core.provider.deprecated.group_test_provider","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.group_test_provider/#module-functions","title":"Module functions","text":"<p><pre><code>test_sub_sub_task(task:\u00a0nornir.core.task.Task,res:\u00a0str) -&gt; nornir.core.task.Result\n</code></pre> <pre><code>test_sub_task(task:\u00a0nornir.core.task.Task,res:\u00a0str) -&gt; nornir.core.task.Result\n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.group_test_provider/#grouptestprovider","title":"GroupTestProvider","text":"<p>The neops base provider contains all methods and required data processing for a concrete provider. To create a new provider, either extend this NeopsBaseProvider or a concrete provider</p> <p>the neops base provider is inherited from the BaseRunCycle</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.group_test_provider/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.group_test_provider/#group-test-provider","title":"Group Test Provider","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.group_test_provider/#properties","title":"Properties","text":"<ul> <li><code>foo</code> (string): Foo Task Form Value.</li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_check/","title":"neops.core.provider.deprecated.interface_check","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_check/#interfacecheckprovider","title":"InterfaceCheckProvider","text":"<p>This Provider is inherited from the <code>NeopsBaseProvider</code>, it brings additional functionality to handle checks.</p> <p>Every Task based on this provider needs a check key where the check result is stored in the database per element.</p> <p>For providers inherits from this provider the check results are written automatically based on the result set of the pre- and run methods per element. It supports check results, boolean values and handels exceptions.</p> <p>This provider should be the base for check providers. So if you create a new check provider with, either extend this <code>NeopsCheckBaseProvider</code> or a concrete check provider</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_check/#check-result","title":"Check Result","text":"<p>see below</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_check/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_check/#check-interface-facts-with-regex","title":"Check Interface Facts with Regex","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_check/#properties","title":"Properties","text":"<ul> <li> <p><code>check_key</code> (string): Set the key where the check is saved.</p> </li> <li> <p><code>checks</code> (array): This description is used as a help message.</p> </li> <li> <p>Items (object)</p> <ul> <li><code>element</code> (object)</li> </ul> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_regex_facts/","title":"neops.core.provider.deprecated.interface_regex_facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_regex_facts/#interfaceregexfactsprovider","title":"InterfaceRegexFactsProvider","text":"<p>This Provider is inherited from the <code>NeopsBaseProvider</code>, it brings additional functionality to handle facts (flexible data structures per entity).</p> <p>Every task based on this provider needs a facts key where the facts result is stored in the database per element.</p> <p>For providers inherits from this provider the facts results are written automatically based on the result set of the pre- and run methods per element. It supports data structures of any kind as long as they are compatible to JSON.</p> <p>This provider should be the base for fact providers. So if you create a new fact provider with, either extend this <code>NeopsFactsBaseProvider</code> or a concrete fact provider</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_regex_facts/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_regex_facts/#add-structured-command-to-facts","title":"Add Structured Command to Facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_regex_facts/#properties","title":"Properties","text":"<ul> <li> <p><code>facts_key</code> (string): Set the key where the facts are saved.</p> </li> <li> <p><code>command</code> (string): Show command to convert to structured data, use $interface$ as variable for interface name .</p> </li> <li> <p><code>regex</code> (string): Regular expression.</p> </li> <li> <p><code>regex_ignore</code> (boolean): Regular expression case sensitive or not. Default: <code>False</code>.</p> </li> <li> <p><code>regex_multi</code> (boolean): Regular expression multiline or not. Default: <code>False</code>.</p> </li> <li> <p><code>regex_dotall</code> (boolean): Dot stands for special characters as well. Default: <code>False</code>.</p> </li> <li> <p><code>match_keys</code> (array): map the matches to keys,                 if multiple (for OR in regex without match use (?:expr1|expr2) ).</p> </li> <li> <p>Items (string)</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_test_provider/","title":"neops.core.provider.deprecated.interface_test_provider","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_test_provider/#module-functions","title":"Module functions","text":"<pre><code>test_failed_sub_task(task:\u00a0nornir.core.task.Task,res:\u00a0str,failed:\u00a0bool\u00a0=\u00a0False) -&gt; nornir.core.task.Result\n</code></pre>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_test_provider/#interfacetestprovider","title":"InterfaceTestProvider","text":"<p>The neops base provider contains all methods and required data processing for a concrete provider. To create a new provider, either extend this NeopsBaseProvider or a concrete provider</p> <p>the neops base provider is inherited from the BaseRunCycle</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_test_provider/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_test_provider/#interface-test-provider","title":"Interface Test Provider","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_test_provider/#properties","title":"Properties","text":"<ul> <li> <p><code>foo</code> (string): Foo Task Form Value.</p> </li> <li> <p><code>bar</code> (boolean): Bar Task Form Value.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_test_provider/#class-variables","title":"Class variables","text":"<pre><code>set_child_to_failed\n</code></pre>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_textfsm_facts/","title":"neops.core.provider.deprecated.interface_textfsm_facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_textfsm_facts/#interfacetextfsmfactsprovider","title":"InterfaceTextFSMFactsProvider","text":"<p>This Provider is inherited from the <code>NeopsBaseProvider</code>, it brings additional functionality to handle facts (flexible data structures per entity).</p> <p>Every task based on this provider needs a facts key where the facts result is stored in the database per element.</p> <p>For providers inherits from this provider the facts results are written automatically based on the result set of the pre- and run methods per element. It supports data structures of any kind as long as they are compatible to JSON.</p> <p>This provider should be the base for fact providers. So if you create a new fact provider with, either extend this <code>NeopsFactsBaseProvider</code> or a concrete fact provider</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_textfsm_facts/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_textfsm_facts/#add-structured-command-to-facts","title":"Add Structured Command to Facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated.interface_textfsm_facts/#properties","title":"Properties","text":"<ul> <li> <p><code>facts_key</code> (string): Set the key where the facts are saved.</p> </li> <li> <p><code>command</code> (string): Show command to convert to structured data, use $interface$ as variable for interface name .</p> </li> <li> <p><code>textfsm</code> (string): TextFSM Template to parse the show output.</p> </li> <li> <p><code>slow_device</code> (integer): Add a factor for longer wait times for heavy loaded devices. Default: <code>0</code>.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.deprecated/","title":"neops.core.provider.deprecated","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_configure_from_jinja/","title":"neops.core.provider.device_configure_from_jinja","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_configure_from_jinja/#devicejinjaconfigureprovider","title":"DeviceJinjaConfigureProvider","text":"<p>Provider to configure a device based on a jinja template</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_configure_from_jinja/#device-configure-parameters","title":"Device Configure Parameters","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_configure_from_jinja/#template","title":"Template","text":"<p>A Jinja Template which is processed before apply the result of this template.</p> <p>The following parameters are passed to the template processing:</p> <ul> <li><code>input</code>: all inputs from the task run arguments</li> <li><code>device</code>: the current device object serialized as dictionary</li> <li><code>neops</code>: the neops object brings methods to access to other elements over the neops.io search<ul> <li><code>neops.search_devices(query)</code>: returns a list of devices found by the search query</li> <li><code>neops.search_interfaces(query)</code>: returns a list of interfaces found by the search query</li> <li><code>neops.search_device_groups(query)</code>: returns a list of groups found by the search query</li> <li><code>neops.search_client(query)</code>: returns a list of clients found by the search query</li> <li><code>neops.get_common_facts(key)</code>: returns the common/global fact of the given key</li> </ul> </li> </ul> <p>For more information on how to build a Jinja2 template, have a look at Appendix under Jinja2</p> <p>Example of device and neops usage (only to show usage, config change doesn't make sense): <pre><code>hostname {{ device.hostname }}\n\n{% for interface in device.interfaces %}\ninterface {{ interface.name }}\n  description NEW-DESCRIPTION\n{% endfor %}\n\n{% for interface in neops.interface_search(\"devices.id:\" ~ device.id ~ \" AND interfaces.description: *CLIENT*\") %}\n    {### process every interface with CLIENT in description #}\ninterface {{ interface.name }}\n  description NEW-DESCRIPTION\n{% endfor %}\n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_configure_from_jinja/#global-base-configure-parameters","title":"Global Base Configure Parameters","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_configure_from_jinja/#apply-method","title":"Apply Method","text":"<p>The apply method descripbes how the configuration is written to the device.</p> <ul> <li><code>cli</code>: the configuration is applied directly in the configration mode</li> <li><code>scp</code>: the configuration is copied (with scp) as a file to the device and applied with an merge operation</li> <li><code>scp-startup</code>: the configuration is copied (with scp) as a file to the device and written to the start up configuration</li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_configure_from_jinja/#slow-devices","title":"Slow Devices","text":"<p>With the <code>slow_device</code> parameter you can specify a delay factor to wait a longer time on responses from             slow devices</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_configure_from_jinja/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_configure_from_jinja/#device-configuration","title":"Device Configuration","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_configure_from_jinja/#properties","title":"Properties","text":"<ul> <li> <p><code>apply</code> (string): Method how to apply the configuration, over cli or copy with scp and merge. Must be one of: <code>['scp', 'cli', 'scp-startup']</code>.</p> </li> <li> <p><code>slow_device</code> (integer): Add a factor for longer wait times for heavy loaded devices. Default: <code>0</code>.</p> </li> <li> <p><code>template</code> (string)</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_configure_from_jinja/#methods","title":"Methods","text":"<p><pre><code>run_on_device(self,task:\u00a0nornir.core.task.Task,device_id:\u00a0int,**kwargs) -&gt; nornir.core.task.Result\n</code></pre> <code>run_on_device</code> is called by the run cycle. \\ It generates the configuration with the given input parameters</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_discovery/","title":"neops.core.provider.device_discovery","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_discovery/#devicediscoveryprovider","title":"DeviceDiscoveryProvider","text":"<p>Discover a device and populate datastructures.</p> <ul> <li><code>Recursive</code>: Try to connect to neighbor devices (found with CDP and LLDP, with the same credentials), if the connection is successful add the device to neops</li> <li><code>Interface Discovery</code>: Populates and updates the interface data structures</li> <li><code>Neighbor Discovery</code>: Set relations between interfaces based on CDP and LLDP neighborships</li> <li><code>Client Discovery</code>: Add Clients to neops.io based on Mac Address-Table information</li> <li><code>Get Configuration</code>: Backup of Device and Interface Configurations to neops.io</li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_discovery/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_discovery/#device-discovery","title":"Device Discovery","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_discovery/#properties","title":"Properties","text":"<ul> <li> <p><code>recursive</code> (boolean): discover and add neighbors with same credentials as well. Default: <code>False</code>.</p> </li> <li> <p><code>include_interfaces</code> (boolean): discover interfaces of the device. Default: <code>True</code>.</p> </li> <li> <p><code>include_neighbors</code> (boolean): discover neighbors and set edges between devices. Default: <code>True</code>.</p> </li> <li> <p><code>include_clients</code> (boolean): discover network clients and assign to interfaces. Default: <code>True</code>.</p> </li> <li> <p><code>get_config</code> (boolean): get the configuration and update database. Default: <code>True</code>.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_discovery/#methods","title":"Methods","text":"<p><pre><code>run_on_nornir_device(self,task:\u00a0nornir.core.task.Task,execute_on:\u00a0List\u00a0=\u00a0None,**kwargs) -&gt; NoneType\n</code></pre> <code>run_on_nornir_device</code> is called by the run cycle. It discovers the network elements</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_exec_from_jinja/","title":"neops.core.provider.device_exec_from_jinja","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_exec_from_jinja/#devicejinjaexecprovider","title":"DeviceJinjaExecProvider","text":"<p>Provider to execute commands in exec mode</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_exec_from_jinja/#device-configure-parameters","title":"Device Configure Parameters","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_exec_from_jinja/#template","title":"Template","text":"<p>A Jinja Template which is processed before apply the result of this template.</p> <p>The following parameters are passed to the template processing:</p> <ul> <li><code>input</code>: all inputs from the task run arguments</li> <li><code>device</code>: the current device object serialized as dictionary</li> <li><code>neops</code>: the neops object brings methods to access to other elements over the neops.io search<ul> <li><code>neops.search_devices(query)</code>: returns a list of devices found by the search query</li> <li><code>neops.search_interfaces(query)</code>: returns a list of interfaces found by the search query</li> <li><code>neops.search_device_groups(query)</code>: returns a list of groups found by the search query</li> <li><code>neops.search_client(query)</code>: returns a list of clients found by the search query</li> <li><code>neops.get_common_facts(key)</code>: returns the common/global fact of the given key</li> </ul> </li> </ul> <p>For more information on how to build a Jinja2 template, have a look at Appendix under Jinja2</p> <p>Example of device and neops usage (only to show usage, config change doesn't make sense): <pre><code>copy ftp://host/file.text flash: :expect destination\nyes\n</code></pre> Expecting User Feedback</p> <p>Normally a prompt is expected after executing commands on a device. But as you can see in the template above, there could be commands whichone are asking for user feedback. To handle user feedbacks you can pass an other value than the prompt to be expected by passing <code>:expect [expect value]</code>.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_exec_from_jinja/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_exec_from_jinja/#device-exec","title":"Device Exec","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_exec_from_jinja/#properties","title":"Properties","text":"<ul> <li><code>template</code> (string): Jinja Template to generate the configuration.</li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_exec_from_jinja/#methods","title":"Methods","text":"<p><pre><code>run_on_device(self,task:\u00a0nornir.core.task.Task,device_id:\u00a0int,**kwargs) -&gt; nornir.core.task.Result\n</code></pre> <code>run_on_device</code> is called by the run cycle. It processes the template and executes the commands on the device</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_image_cleanup/","title":"neops.core.provider.device_image_cleanup","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_image_cleanup/#deviceimagecleanupprovider","title":"DeviceImageCleanUpProvider","text":"<p>Clean up old images on devices</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_image_cleanup/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_image_cleanup/#json-schema_1","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_napalm_facts/","title":"neops.core.provider.device_napalm_facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_napalm_facts/#devicenapalmfacts","title":"DeviceNapalmFacts","text":"<p>Get napalm facts from a device</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_napalm_facts/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_napalm_facts/#add-structured-command-to-facts","title":"Add Structured Command to Facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_napalm_facts/#properties","title":"Properties","text":"<ul> <li> <p><code>facts_key</code> (string): Set the key where the facts are saved.</p> </li> <li> <p><code>napalm_fact</code> (string): Element to get facts from napalm.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_restart/","title":"neops.core.provider.device_restart","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_restart/#devicerestartprovider","title":"DeviceRestartProvider","text":"<p>Provider to restart a device (for example after upgrade)</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_restart/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_restart/#json-schema_1","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_rollback/","title":"neops.core.provider.device_rollback","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_rollback/#devicerollbackprovider","title":"DeviceRollbackProvider","text":"<p>Provider to rollback configuration to version from a given date</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_rollback/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_rollback/#json-schema_1","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_rollback/#run-input-json-schema","title":"Run Input JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_rollback/#interface-rollback","title":"Interface Rollback","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_rollback/#properties","title":"Properties","text":"<ul> <li><code>rollback_date</code> (string)</li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_rommon_upgrade/","title":"neops.core.provider.device_rommon_upgrade","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_rommon_upgrade/#devicerommonupgradeprovider","title":"DeviceRommonUpgradeProvider","text":"<p>Provider to Upgrade Rommon of Cisco Devices</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_rommon_upgrade/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_rommon_upgrade/#device-upgrade-rommon","title":"Device Upgrade ROMMON","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_rommon_upgrade/#properties","title":"Properties","text":"<ul> <li><code>source_url</code> (string): from this URL the image will be loaded.</li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_rommon_upgrade/#run-input-json-schema","title":"Run Input JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_rommon_upgrade/#device-upgrade-rommon_1","title":"Device Upgrade ROMMON","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_rommon_upgrade/#properties_1","title":"Properties","text":"<ul> <li> <p><code>image</code> (string): from this URL the image will be loaded.</p> </li> <li> <p><code>md5</code> (string): MD5 sum to verify. Default: ``.</p> </li> <li> <p><code>min_space</code> (integer): minimum file size required. Default: <code>0</code>.</p> </li> <li> <p><code>overwrite</code> (boolean): overwrite image if file exists on device. Default: <code>False</code>.</p> </li> <li> <p><code>restart</code> (boolean): restart device when image is copied and installed. Default: <code>False</code>.</p> </li> <li> <p><code>vrf</code> (string): VRF where we should copy. Default: ``.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_rommon_upgrade_unattended/","title":"neops.core.provider.device_rommon_upgrade_unattended","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_rommon_upgrade_unattended/#devicerommonupgradeunattendedprovider","title":"DeviceRommonUpgradeUnattendedProvider","text":"<p>Provider to upgrade rommon of a Cisco device (Unattended, define the values in the task and don't do a dry run)</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_rommon_upgrade_unattended/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_rommon_upgrade_unattended/#device-upgrade","title":"Device Upgrade","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_rommon_upgrade_unattended/#properties","title":"Properties","text":"<ul> <li> <p><code>source_url</code> (string): from this URL the image will be loaded.</p> </li> <li> <p><code>vrf</code> (string): VRF where we should copy. Default: ``.</p> </li> <li> <p><code>models</code> (array): This description is used as a help message.</p> </li> <li> <p>Items (object)</p> <ul> <li> <p><code>model_regex</code> (string): Default: <code>^$</code>.</p> </li> <li> <p><code>image</code> (string): from this URL the image will be loaded.</p> </li> <li> <p><code>md5</code> (string): MD5 sum to verify. Default: ``.</p> </li> <li> <p><code>min_space</code> (integer): minimum file size required. Default: <code>0</code>.</p> </li> <li> <p><code>overwrite</code> (boolean): overwrite image if file exists on device. Default: <code>False</code>.</p> </li> <li> <p><code>restart</code> (boolean): restart device when image is copied and installed. Default: <code>False</code>.</p> </li> </ul> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_snmp_facts/","title":"neops.core.provider.device_snmp_facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_snmp_facts/#devicesnmpfactsprovider","title":"DeviceSNMPFactsProvider","text":"<p>Provider to get facts from SNMP</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_snmp_facts/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_snmp_facts/#add-structured-command-to-facts","title":"Add Structured Command to Facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_snmp_facts/#properties","title":"Properties","text":"<ul> <li> <p><code>facts_key</code> (string): Set the key where the facts are saved.</p> </li> <li> <p><code>oidKeyPairs</code> (array): Specify which OIDs you would like to store as a fact. The fact key can help you to identify the value later.</p> </li> <li> <p>Items (object)</p> <ul> <li> <p><code>oid</code> (string)</p> </li> <li> <p><code>key</code> (string)</p> </li> </ul> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_snmp_facts/#methods","title":"Methods","text":"<pre><code>oid_str_to_tuple(self,oid:\u00a0str) -&gt; \n</code></pre>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_stack_auto_upgrade/","title":"neops.core.provider.device_stack_auto_upgrade","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_stack_auto_upgrade/#devicestackautoupgradeunattendedprovider","title":"DeviceStackAutoUpgradeUnattendedProvider","text":"<p>Provider to enable stack auto upgrade functionality (for staging purpose)</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_stack_auto_upgrade/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_stack_auto_upgrade/#stack-auto-upgrade","title":"Stack Auto Upgrade","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_stack_auto_upgrade/#properties","title":"Properties","text":"<ul> <li><code>reload_on_members</code> (number): How long should the process wait till the Stack Members are ready. Default: <code>1200</code>.</li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade/","title":"neops.core.provider.device_upgrade","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade/#deviceupgradeprovider","title":"DeviceUpgradeProvider","text":"<p>Provider to upgrade device images</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade/#device-upgrade","title":"Device Upgrade","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade/#properties","title":"Properties","text":"<ul> <li><code>source_url</code> (string): from this URL the image will be loaded.</li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade/#run-input-json-schema","title":"Run Input JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade/#device-upgrade_1","title":"Device Upgrade","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade/#properties_1","title":"Properties","text":"<ul> <li> <p><code>image</code> (string): from this URL the image will be loaded.</p> </li> <li> <p><code>md5</code> (string): MD5 sum to verify. Default: ``.</p> </li> <li> <p><code>min_space</code> (integer): minimum file size required. Default: <code>0</code>.</p> </li> <li> <p><code>overwrite</code> (boolean): overwrite image if file exists on device. Default: <code>False</code>.</p> </li> <li> <p><code>restart</code> (boolean): restart device when image is copied and installed. Default: <code>False</code>.</p> </li> <li> <p><code>vrf</code> (string): VRF where we should copy. Default: ``.</p> </li> <li> <p><code>save_config_if_required</code> (boolean): Save config before restart if asked so. Default: <code>True</code>.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade_direct/","title":"neops.core.provider.device_upgrade_direct","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade_direct/#deviceupgradedirectprovider","title":"DeviceUpgradeDirectProvider","text":"<p>Provider to upgrade device image (without dry run)</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade_direct/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade_direct/#device-upgrade","title":"Device Upgrade","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade_direct/#properties","title":"Properties","text":"<ul> <li><code>source_url</code> (string): from this URL the image will be loaded.</li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade_direct/#run-input-json-schema","title":"Run Input JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade_direct/#device-upgrade_1","title":"Device Upgrade","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade_direct/#properties_1","title":"Properties","text":"<ul> <li> <p><code>image</code> (string): from this URL the image will be loaded.</p> </li> <li> <p><code>md5</code> (string): MD5 sum to verify. Default: ``.</p> </li> <li> <p><code>min_space</code> (integer): minimum file size required. Default: <code>0</code>.</p> </li> <li> <p><code>overwrite</code> (boolean): overwrite image if file exists on device. Default: <code>False</code>.</p> </li> <li> <p><code>restart</code> (boolean): restart device when image is copied and installed. Default: <code>False</code>.</p> </li> <li> <p><code>vrf</code> (string): VRF where we should copy. Default: ``.</p> </li> <li> <p><code>save_config_if_required</code> (boolean): Save config before restart if asked so. Default: <code>True</code>.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade_unattended/","title":"neops.core.provider.device_upgrade_unattended","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade_unattended/#deviceupgradeunattendedprovider","title":"DeviceUpgradeUnattendedProvider","text":"<p>Provider to upgrade device image (Unattended, define the values in the task and don't do a dry run)</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade_unattended/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade_unattended/#device-upgrade","title":"Device Upgrade","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.device_upgrade_unattended/#properties","title":"Properties","text":"<ul> <li> <p><code>source_url</code> (string): from this URL the image will be loaded.</p> </li> <li> <p><code>vrf</code> (string): VRF where we should copy. Default: ``.</p> </li> <li> <p><code>models</code> (array): This description is used as a help message.</p> </li> <li> <p>Items (object)</p> <ul> <li> <p><code>model_regex</code> (string): Default: <code>^$</code>.</p> </li> <li> <p><code>image</code> (string): from this URL the image will be loaded.</p> </li> <li> <p><code>md5</code> (string): MD5 sum to verify. Default: ``.</p> </li> <li> <p><code>min_space</code> (integer): minimum file size required. Default: <code>0</code>.</p> </li> <li> <p><code>overwrite</code> (boolean): overwrite image if file exists on device. Default: <code>False</code>.</p> </li> <li> <p><code>restart</code> (boolean): restart device when image is copied and installed. Default: <code>False</code>.</p> </li> <li> <p><code>save_config_if_required</code> (boolean): Save config before restart if asked so. Default: <code>True</code>.</p> </li> <li> <p><code>reload_wait_time</code> (number): How long should the process wait at reload after upgrade. Default: <code>1200</code>.</p> </li> </ul> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.exceptions.base/","title":"neops.core.provider.exceptions.base","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.exceptions.base/#invalidtaskargumentsexception","title":"InvalidTaskArgumentsException","text":"<p>Common base class for all non-exit exceptions.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.exceptions.base/#invalidtaskexception","title":"InvalidTaskException","text":"<p>Common base class for all non-exit exceptions.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.exceptions.base/#neopstaskbaseexception","title":"NeopsTaskBaseException","text":"<p>Common base class for all non-exit exceptions.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.exceptions.base/#wrongexecuteentityexception","title":"WrongExecuteEntityException","text":"<p>Common base class for all non-exit exceptions.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.exceptions/","title":"neops.core.provider.exceptions","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_check_aggregation/","title":"neops.core.provider.generic_check_aggregation","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_check_aggregation/#genericcheckaggregation","title":"GenericCheckAggregation","text":"<p>Aggregate Check Results to an other entity</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_check_aggregation/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_check_aggregation/#excel-to-process-tasks","title":"Excel to Process Tasks","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_check_aggregation/#properties","title":"Properties","text":"<ul> <li> <p><code>check_key</code> (string): Set the key where the check is saved.</p> </li> <li> <p><code>aggregate_from</code> (string): Aggregate from entity Type. Must be one of: <code>['DEVICE', 'INTERFACE']</code>.</p> </li> <li> <p><code>check_key_from</code> (string): set the check with the check key to aggregate on. Default: ``.</p> </li> <li> <p><code>aggregate_to</code> (string): Aggregate to entity Type. Must be one of: <code>['GROUP', 'DEVICE']</code>.</p> </li> <li> <p><code>percent</code> (integer): . Default: <code>100</code>.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_from_excel/","title":"neops.core.provider.generic_from_excel","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_from_excel/#genericfromexcel","title":"GenericFromExcel","text":"<p>Provider to summarize other tasks and take input values from excel.</p> <p>Every other task is called by its id or uniquetaskname, it has two templates on to set the entities on which the task is called and one to pass the input values.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_from_excel/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_from_excel/#process-tasks-with-excel-as-input","title":"Process Tasks with Excel as Input","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_from_excel/#properties","title":"Properties","text":"<ul> <li> <p><code>run_as</code> (string): Select on which entity the task should run on. Must be one of: <code>['GLOBAL', 'GROUP', 'DEVICE', 'INTERFACE', 'CLIENT']</code>.</p> </li> <li> <p><code>header_num</code> (number): On which line in the sheet is the header placed. Default: <code>1</code>.</p> </li> <li> <p><code>tasks</code> (array): This description is used as a help message.</p> </li> <li> <p>Items (object)</p> <ul> <li> <p><code>titleProp</code> (string)</p> </li> <li> <p><code>run_as</code> (string): Select on which execute on entities will be passed to the task. Must be one of: <code>['GROUP', 'DEVICE', 'INTERFACE', 'CLIENT']</code>.</p> </li> <li> <p><code>allow_all</code> (boolean): some providers have the ability to run on all elements if there are none given, decide if this is fine for your task. Default: <code>False</code>.</p> </li> <li> <p><code>entity_template</code> (string): Get a List of Entity by the Template. Default: <code>{% set device_list = [] %} {% for device in neops.search_devices(\"devices.hostname: *.neops.io\") %} {{ device.hostname }} {% do device_list.append(device.id) %} {% endfor %} {% do neops.set_entities(device_list) %}</code>.</p> </li> <li> <p><code>task_id</code> (number): Default: <code>0</code>.</p> </li> <li> <p><code>task_uniquename</code> (string): Set unique task name of task to process (task_id has priority).</p> </li> <li> <p><code>task_main</code> (boolean): Include pre and post run tasks in this step. Default: <code>True</code>.</p> </li> <li> <p><code>task_template</code> (string): parse excel content (given as excel var to jinja) and provide the data structure for the task. Default: <code>{% do neops.set_params({}) %}</code>.</p> </li> </ul> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_from_excel/#run-input-json-schema","title":"Run Input JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_from_excel/#process-tasks-with-excel-as-input_1","title":"Process Tasks with Excel as Input","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_from_excel/#properties_1","title":"Properties","text":"<ul> <li><code>excel</code> (string): Task input values from Excel file.</li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_from_excel/#excel","title":"Excel","text":"<p>The excel is passed as a dictionary.</p> <p>Every sheet has its own key and contains list as value. The list contans a dictionary for every row, the key are set from the columns titles</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_from_excel/#entity-and-params-templates","title":"Entity and Params Templates","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_from_excel/#entity-template","title":"Entity Template","text":"<p>A Jinja Template which is processed to select the entities where the task is applied on.</p> <p>The following parameters are passed to the template processing:</p> <ul> <li><code>input</code>: all inputs from the task run arguments</li> <li><code>excel</code>: all dictionary of excel content</li> <li><code>elements</code>: the current selected objects based on <code>run_as</code> serialized as dictionary</li> <li><code>neops</code>: the neops object brings methods to access to other elements over the neops.io search and to save the facts objects<ul> <li><code>neops.search_devices(query)</code>: returns a list of devices found by the search query</li> <li><code>neops.search_interfaces(query)</code>: returns a list of interfaces found by the search query</li> <li><code>neops.search_device_groups(query)</code>: returns a list of groups found by the search query</li> <li><code>neops.search_client(query)</code>: returns a list of clients found by the search query</li> <li><code>neops.get_common_facts(key)</code>: returns the common/global fact of the given key</li> <li><code>neops.set_entities(ids)</code>: sets entities to run the task as list of ids</li> </ul> </li> </ul> <p>For more information on how to build a Jinja2 template, have a look at Appendix under Jinja2</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_from_excel/#params-template","title":"Params Template","text":"<p>A Jinja Template which is processed to pass the params to the task.</p> <p>The following parameters are passed to the template processing:</p> <ul> <li><code>input</code>: all inputs from the task run arguments</li> <li><code>excel</code>: all dictionary of excel content</li> <li><code>entities</code>: ids of elements to run the task on</li> <li><code>elements</code>: entity objects serialized as dictionary</li> <li><code>neops</code>: the neops object brings methods to access to other elements over the neops.io search and to save the facts objects<ul> <li><code>neops.search_devices(query)</code>: returns a list of devices found by the search query</li> <li><code>neops.search_interfaces(query)</code>: returns a list of interfaces found by the search query</li> <li><code>neops.search_device_groups(query)</code>: returns a list of groups found by the search query</li> <li><code>neops.search_client(query)</code>: returns a list of clients found by the search query</li> <li><code>neops.get_common_facts(key)</code>: returns the common/global fact of the given key</li> <li><code>neops.set_params(dictionary)</code>: sets params as input values for the task</li> </ul> </li> </ul> <p>For more information on how to build a Jinja2 template, have a look at Appendix under Jinja2</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_from_excel/#methods","title":"Methods","text":"<p><pre><code>run_global(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,dry_run:\u00a0bool,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],search_query:\u00a0str,task_kwargs:\u00a0Dict[Any,\u00a0Any],result=neops.core.provider.base.result.provider_global_result.ProviderGlobalResult,**kwargs) -&gt; Any\n</code></pre> Process all subtasks</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_jinja_check/","title":"neops.core.provider.generic_jinja_check","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_jinja_check/#genericjinjacheckprovider","title":"GenericJinjaCheckProvider","text":"<p>This Provider is used to set check results from existing facts or checks.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_jinja_check/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_jinja_check/#generic-jinja-check","title":"Generic Jinja Check","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_jinja_check/#properties","title":"Properties","text":"<ul> <li> <p><code>check_key</code> (string): Set the key where the check is saved.</p> </li> <li> <p><code>check_on</code> (string): Select on which entity you want save the Check. Must be one of: <code>['GROUP', 'DEVICE', 'INTERFACE', 'CLIENT ON GROUP', 'CLIENT ON INTERFACE']</code>.</p> </li> <li> <p><code>template</code> (string): Jinja Template to set the check results. Default: <code>{% do neops.set_result(True) %} {% do neops.set_reason(\"because\") %}</code>.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_jinja_check/#template","title":"Template","text":"<p>The Jinja template which is processed to map the values to the new facts.</p> <p>The following parameters are passed to the template processing:</p> <ul> <li><code>input</code>: all inputs from the task run arguments</li> <li>entity objects based on <code>check_on</code><ul> <li><code>none</code> on <code>GLOBAL</code></li> <li><code>device_group</code>: on <code>GROUP</code>, the current device group object serialized as dictionary</li> <li><code>device</code>: on <code>DEVICE</code>, the current device object serialized as dictionary</li> <li><code>interface</code>: on <code>INTERFACE</code>, the current interface object serialized as dictionary</li> <li><code>client</code>: on <code>CLIENT ON GROUP</code> or <code>CLIENT ON INTERFACE</code>, the current client object serialized as dictionary</li> </ul> </li> <li><code>neops</code>: the neops object brings methods to access to other elements over the neops.io search and to save the facts objects<ul> <li><code>neops.search_devices(query)</code>: returns a list of devices found by the search query</li> <li><code>neops.search_interfaces(query)</code>: returns a list of interfaces found by the search query</li> <li><code>neops.search_device_groups(query)</code>: returns a list of groups found by the search query</li> <li><code>neops.search_client(query)</code>: returns a list of clients found by the search query</li> <li><code>neops.get_common_facts(key)</code>: returns the common/global fact of the given key</li> <li><code>neops.set_result(result)</code>: sets the check result, if the check is successful (<code>ok</code> or <code>true</code>), not successful (<code>nok</code> or <code>false</code>) or if the check execution is failed (any other value)</li> <li><code>neops.set_metrics(metrics)</code>: set metrics values (dictionary) of a check</li> <li><code>neops.set_reason(reason)</code>: set reason for the check result</li> <li>set reference to related results for teardown<ul> <li><code>neops.add_related_device_group_facts(device_group_id, fact_key)</code>: set reference to device group facts by id and fact key</li> <li><code>neops.add_related_device_facts(device_id, fact_key)</code>: set reference to device facts by id and fact key</li> <li><code>neops.add_related_interface_facts(interface_id, fact_key)</code>: set reference to interface facts by id and fact key</li> <li><code>neops.add_related_client_facts(client_id, fact_key)</code>: set reference to client facts by id and fact key</li> <li><code>neops.add_related_device_group_check(device_group_id, check_key)</code>: set reference to device group check by id and check key</li> <li><code>neops.add_related_device_check(device_id, check_key)</code>: set reference to device check by id and check key</li> <li><code>neops.add_related_interface_check(interface_id, check_key)</code>: set reference to interface check by id and check key</li> <li><code>neops.add_related_client_check(client_id, check_key)</code>: set reference to client check by id and check key</li> </ul> </li> </ul> </li> </ul> <p>For more information on how to build a Jinja2 template, have a look at Appendix under Jinja2</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_jinja_check/#methods","title":"Methods","text":"<p><pre><code>run_on_client_of_interface(self,task:\u00a0nornir.core.task.Task,client_id:\u00a0int,check_on:\u00a0str,template:\u00a0str,**kwargs) -&gt; Union[neops.core.provider.base.base_check.NeopsCheckResult,\u00a0NoneType]\n</code></pre> Processes the template if the \"Check on\" is set to CLIENT ON INTERFACE</p> <p><pre><code>run_on_client_of_location(self,client_id:\u00a0int,check_on:\u00a0str,template:\u00a0str,**kwargs) -&gt; Union[neops.core.provider.base.base_check.NeopsCheckResult,\u00a0NoneType]\n</code></pre> Processes the template if the \"Check on\" is set to CLIENT ON GROUP</p> <p><pre><code>run_on_device(self,task:\u00a0nornir.core.task.Task,device_id:\u00a0int,check_on:\u00a0str,template:\u00a0str,**kwargs) -&gt; Union[neops.core.provider.base.base_check.NeopsCheckResult,\u00a0NoneType]\n</code></pre> Processes the template if the \"Check on\" is set to DEVICE</p> <p><pre><code>run_on_device_group(self,device_group_id:\u00a0int,check_on:\u00a0str,template:\u00a0str,**kwargs) -&gt; Union[neops.core.provider.base.base_check.NeopsCheckResult,\u00a0NoneType]\n</code></pre> Processes the template if the \"Check on\" is set to GROUP</p> <p><pre><code>run_on_interface(self,task:\u00a0nornir.core.task.Task,interface_id:\u00a0int,check_on:\u00a0str,template:\u00a0str,**kwargs) -&gt; Union[neops.core.provider.base.base_check.NeopsCheckResult,\u00a0NoneType]\n</code></pre> Processes the template if the \"Check on\" is set to INTERFACE</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_jinja_facts/","title":"neops.core.provider.generic_jinja_facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_jinja_facts/#genericjinjafactsprovider","title":"GenericJinjaFactsProvider","text":"<p>This Provider is used to restructure new facts from existing facts.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_jinja_facts/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_jinja_facts/#generic-jinja-check","title":"Generic Jinja Check","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_jinja_facts/#properties","title":"Properties","text":"<ul> <li> <p><code>facts_key</code> (string): Set the key where the facts are saved.</p> </li> <li> <p><code>add_facts_to</code> (string): Select on which entity you want save the Facts. Must be one of: <code>['GLOBAL', 'GROUP', 'DEVICE', 'INTERFACE', 'CLIENT ON GROUP', 'CLIENT ON INTERFACE']</code>.</p> </li> <li> <p><code>mapping_template</code> (string): Default: <code>{% do neops.set_facts({}) %}</code>.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_jinja_facts/#mapping-template","title":"Mapping Template","text":"<p>The Jinja template which is processed to map the values to the new facts.</p> <p>The following parameters are passed to the template processing:</p> <ul> <li><code>input</code>: all inputs from the task run arguments</li> <li>entity objects based on add_facts_to<ul> <li><code>none</code> on <code>GLOBAL</code></li> <li><code>device_group</code>: on <code>GROUP</code>, the current device group object serialized as dictionary</li> <li><code>device</code>: on <code>DEVICE</code>, the current device object serialized as dictionary</li> <li><code>interface</code>: on <code>INTERFACE</code>, the current interface object serialized as dictionary</li> <li><code>client</code>: on <code>CLIENT ON GROUP</code> or <code>CLIENT ON INTERFACE</code>, the current client object serialized as dictionary</li> </ul> </li> <li><code>neops</code>: the neops object brings methods to access to other elements over the neops.io search and to save the facts objects<ul> <li><code>neops.search_devices(query)</code>: returns a list of devices found by the search query</li> <li><code>neops.search_interfaces(query)</code>: returns a list of interfaces found by the search query</li> <li><code>neops.search_device_groups(query)</code>: returns a list of groups found by the search query</li> <li><code>neops.search_client(query)</code>: returns a list of clients found by the search query</li> <li><code>neops.get_common_facts(key)</code>: returns the common/global fact of the given key</li> <li><code>neops.set_facts(dictionary)</code>: sets the facts to be saved</li> </ul> </li> </ul> <p>For more information on how to build a Jinja2 template, have a look at Appendix under Jinja2</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_jinja_facts/#methods","title":"Methods","text":"<p><pre><code>run_global(self,task_kwargs:\u00a0Dict[Any,\u00a0Any],**kwargs) -&gt; Union[Dict[Any,\u00a0Any],\u00a0NoneType]\n</code></pre> Processes the mapping template if the \"add facts to\" is set to GLOBAL</p> <p><pre><code>run_on_client_of_interface(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,dry_run:\u00a0bool,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],search_query:\u00a0str,task_kwargs:\u00a0Dict[Any,\u00a0Any],task:\u00a0nornir.core.task.Task,nornir_device_id:\u00a0int,device_id:\u00a0int,interface_id:\u00a0int,client_id:\u00a0int,client_result:\u00a0neops.core.provider.base.result.coupled_provider_result_types.ProviderClientResult,**kwargs) -&gt; Union[Dict[Any,\u00a0Any],\u00a0NoneType]\n</code></pre> Processes the mapping template if the \"add facts to\" is set to CLIENT ON INTERFACE</p> <p><pre><code>run_on_client_of_location(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,dry_run:\u00a0bool,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],search_query:\u00a0str,task_kwargs:\u00a0Dict[Any,\u00a0Any],location_id:\u00a0int,client_id:\u00a0int,client_result,**kwargs) -&gt; Union[Dict[Any,\u00a0Any],\u00a0NoneType]\n</code></pre> Processes the mapping template if the \"add facts to\" is set to CLIENT ON GROUP</p> <p><pre><code>run_on_device(self,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],task_kwargs:\u00a0Dict[Any,\u00a0Any],task:\u00a0nornir.core.task.Task,nornir_device_id:\u00a0int,device_id:\u00a0int,device_result:\u00a0neops.core.provider.base.result.coupled_provider_result_types.ProviderDeviceResult,**kwargs) -&gt; Union[Dict[Any,\u00a0Any],\u00a0NoneType]\n</code></pre> Processes the mapping template if the \"add facts to\" is set to DEVICE</p> <p><pre><code>run_on_device_group(self,device_group_id:\u00a0int,task_kwargs:\u00a0Dict[Any,\u00a0Any],device_group_result:\u00a0neops.core.provider.base.result.coupled_provider_result_types.ProviderDeviceGroupResult,**kwargs) -&gt; Union[Dict[Any,\u00a0Any],\u00a0NoneType]\n</code></pre> Processes the mapping template if the \"add facts to\" is set to GROUP</p> <p><pre><code>run_on_interface(self,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],task_kwargs:\u00a0Dict[Any,\u00a0Any],task:\u00a0nornir.core.task.Task,nornir_device_id:\u00a0int,device_id:\u00a0int,interface_id:\u00a0int,interface_result:\u00a0neops.core.provider.base.result.coupled_provider_result_types.ProviderInterfaceResult,**kwargs) -&gt; Union[Dict[Any,\u00a0Any],\u00a0NoneType]\n</code></pre> Processes the mapping template if the \"add facts to\" is set to INTERFACE</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_ping/","title":"neops.core.provider.generic_ping","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_ping/#genericping","title":"GenericPing","text":"<p>Ping Targets and save results as facts</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_ping/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_ping/#add-structured-command-to-facts","title":"Add Structured Command to Facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_ping/#properties","title":"Properties","text":"<ul> <li> <p><code>facts_key</code> (string): Set the key where the facts are saved.</p> </li> <li> <p><code>add_facts_to</code> (string): Add Facts to Group, Device, Interface or Clients. Must be one of: <code>['GLOBAL', 'GROUP', 'CLIENT OF LOCATIONS', 'DEVICE', 'INTERFACE', 'CLIENT OF INTERFACE']</code>.</p> </li> <li> <p><code>destination_template</code> (string): List of Targets (1 per line). Default: <code>8.8.8.8</code>.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_report/","title":"neops.core.provider.generic_report","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_report/#genericreportprovider","title":"GenericReportProvider","text":"<p>Provider to generate a custom output to copy pase to an other application</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_report/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_report/#excel-to-process-tasks","title":"Excel to Process Tasks","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_report/#properties","title":"Properties","text":"<ul> <li> <p><code>report_for</code> (string): Select on which entity you want to report. Must be one of: <code>['GROUP', 'DEVICE', 'INTERFACE', 'CLIENT']</code>.</p> </li> <li> <p><code>template</code> (string): Jinja template for the report.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_report/#report-templates","title":"Report Templates","text":"<p>A Jinja Template to generate the report.</p> <p>The following parameters are passed to the template processing:</p> <ul> <li><code>input</code>: all inputs from the task run arguments</li> <li>entity objects based on add_facts_to<ul> <li><code>device_group</code>: on <code>GROUP</code>, the current device group object serialized as dictionary</li> <li><code>device</code>: on <code>DEVICE</code>, the current device object serialized as dictionary</li> <li><code>interface</code>: on <code>INTERFACE</code>, the current interface object serialized as dictionary</li> <li><code>client</code>: on <code>CLIENT ON GROUP</code> or <code>CLIENT ON INTERFACE</code>, the current client object serialized as dictionary</li> </ul> </li> <li><code>neops</code>: the neops object brings methods to access to other elements over the neops.io search and to save the facts objects<ul> <li><code>neops.search_devices(query)</code>: returns a list of devices found by the search query</li> <li><code>neops.search_interfaces(query)</code>: returns a list of interfaces found by the search query</li> <li><code>neops.search_device_groups(query)</code>: returns a list of groups found by the search query</li> <li><code>neops.search_client(query)</code>: returns a list of clients found by the search query</li> <li><code>neops.get_common_facts(key)</code>: returns the common/global fact of the given key</li> </ul> </li> </ul> <p>For more information on how to build a Jinja2 template, have a look at Appendix under Jinja2</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_report/#methods","title":"Methods","text":"<p><pre><code>run_on_client_of_interface(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,dry_run:\u00a0bool,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],search_query:\u00a0str,task_kwargs:\u00a0Dict[Any,\u00a0Any],task:\u00a0nornir.core.task.Task,nornir_device_id:\u00a0int,device_id:\u00a0int,interface_id:\u00a0int,client_id:\u00a0int,report_for:\u00a0str,**kwargs) -&gt; Any\n</code></pre> Process report on CLIENT</p> <p><pre><code>run_on_device(self,task:\u00a0nornir.core.task.Task,device_id:\u00a0int,report_for:\u00a0str,template:\u00a0str,**kwargs) -&gt; Any\n</code></pre> Process report on DEVICE</p> <p><pre><code>run_on_device_group(self,device_group_id:\u00a0int,report_for:\u00a0str,template:\u00a0str,**kwargs) -&gt; Any\n</code></pre> Process report on GROUP</p> <p><pre><code>run_on_interface(self,task:\u00a0nornir.core.task.Task,device_id:\u00a0int,interface_id:\u00a0int,report_for:\u00a0str,template:\u00a0str,**kwargs) -&gt; Any\n</code></pre> Process report on INTERFACE</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_rest_facts/","title":"neops.core.provider.generic_rest_facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_rest_facts/#genericrestfactsprovider","title":"GenericRestFactsProvider","text":"<p>Provider to get facts from a GET on a REST API</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_rest_facts/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_rest_facts/#add-return-value-from-rest-call-to-facts","title":"Add Return Value from REST call to Facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_rest_facts/#properties","title":"Properties","text":"<ul> <li> <p><code>facts_key</code> (string): Set the key where the facts are saved.</p> </li> <li> <p><code>url</code> (string): Jinja Template can be used to get parameters, element of run on is passed to Jinja Template.</p> </li> <li> <p><code>request_on</code> (string): Run Global or on Group, Device or Interface. Must be one of: <code>['GLOBAL', 'GROUP', 'DEVICE', 'INTERFACE']</code>.</p> </li> <li> <p><code>auth</code> (object)</p> </li> <li> <p><code>mapping</code> (object)</p> </li> <li> <p><code>add_facts_to</code> (string): Add Facts to Group, Device or Interface. Must be one of: <code>['GROUP', 'DEVICE', 'INTERFACE']</code>.</p> </li> <li> <p><code>mapping_template</code> (string): Return string from Jinja Template is evaluated and mapped to given element. Default: <code>{% do neops.set_facts(response) %}</code>.</p> </li> <li> <p><code>headers</code> (array)</p> </li> <li> <p>Items (object)</p> <ul> <li> <p><code>header_name</code> (string)</p> </li> <li> <p><code>header_value</code> (string)</p> </li> </ul> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_rest_facts/#url-template","title":"URL Template","text":"<p>A Jinja Template to generate the URL whichone is requested.</p> <p>The following parameters are passed to the template processing:</p> <ul> <li><code>input</code>: all inputs from the task run arguments</li> <li>entity objects based on <code>request_on</code><ul> <li>none: _on <code>GLOBAL</code></li> <li><code>device_group</code>: on <code>GROUP</code>, the current device group object serialized as dictionary</li> <li><code>device</code>: on <code>DEVICE</code>, the current device object serialized as dictionary</li> <li><code>interface</code>: on <code>INTERFACE</code>, the current interface object serialized as dictionary</li> </ul> </li> <li><code>neops</code>: the neops object brings methods to access to other elements over the neops.io search and to save the facts objects<ul> <li><code>neops.search_devices(query)</code>: returns a list of devices found by the search query</li> <li><code>neops.search_interfaces(query)</code>: returns a list of interfaces found by the search query</li> <li><code>neops.search_device_groups(query)</code>: returns a list of groups found by the search query</li> <li><code>neops.search_client(query)</code>: returns a list of clients found by the search query</li> <li><code>neops.get_common_facts(key)</code>: returns the common/global fact of the given key</li> <li><code>neops.set_facts(dictionary)</code>: sets the facts to be saved</li> </ul> </li> </ul> <p>For more information on how to build a Jinja2 template, have a look at Appendix under Jinja2</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_rest_facts/#mapping-template","title":"Mapping Template","text":"<p>A Jinja Template to map the response to facts.</p> <p>The following parameters are passed to the template processing:</p> <ul> <li><code>input</code>: all inputs from the task run arguments</li> <li>entity objects based on <code>request_on</code><ul> <li>none: _on <code>GLOBAL</code></li> <li><code>device_group</code>: on <code>GROUP</code>, the current device group object serialized as dictionary</li> <li><code>device</code>: on <code>DEVICE</code>, the current device object serialized as dictionary</li> <li><code>interface</code>: on <code>INTERFACE</code>, the current interface object serialized as dictionary</li> </ul> </li> <li><code>response</code>: response result or list of response results based on related objects</li> <li><code>neops</code>: the neops object brings methods to access to other elements over the neops.io search and to save the facts objects<ul> <li><code>neops.search_devices(query)</code>: returns a list of devices found by the search query</li> <li><code>neops.search_interfaces(query)</code>: returns a list of interfaces found by the search query</li> <li><code>neops.search_device_groups(query)</code>: returns a list of groups found by the search query</li> <li><code>neops.search_client(query)</code>: returns a list of clients found by the search query</li> <li><code>neops.get_common_facts(key)</code>: returns the common/global fact of the given key</li> <li><code>neops.set_facts(dictionary)</code>: sets the facts to be saved</li> </ul> </li> </ul> <p>For more information on how to build a Jinja2 template, have a look at Appendix under Jinja2</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_rest_facts/#methods","title":"Methods","text":"<p><pre><code>get_rest(self,url:\u00a0str,auth:\u00a0Dict\u00a0=\u00a0None,headers:\u00a0List\u00a0=\u00a0None) -&gt; Dict\n</code></pre> Process the requests based on authentication, headers and the request URL</p> <p><pre><code>pre_run_global(self,request_on:\u00a0str,url:\u00a0str,task_input_kwargs:\u00a0Dict,auth:\u00a0Dict\u00a0=\u00a0None,headers:\u00a0List\u00a0=\u00a0None,**kwargs) -&gt; Any\n</code></pre> Process a global request</p> <p><pre><code>pre_run_on_device(self,task:\u00a0nornir.core.task.Task,device_id:\u00a0int,request_on:\u00a0str,url:\u00a0str,task_input_kwargs:\u00a0Dict,auth:\u00a0Dict\u00a0=\u00a0None,headers:\u00a0List\u00a0=\u00a0None,**kwargs) -&gt; Any\n</code></pre> Process a request per device</p> <p><pre><code>pre_run_on_device_group(self,device_group_id:\u00a0int,request_on:\u00a0str,url:\u00a0str,task_input_kwargs:\u00a0Dict,auth:\u00a0Dict\u00a0=\u00a0None,headers:\u00a0List\u00a0=\u00a0None,**kwargs) -&gt; Any\n</code></pre> Process a request per group</p> <p><pre><code>pre_run_on_interface(self,task:\u00a0nornir.core.task.Task,interface_id:\u00a0int,request_on:\u00a0str,url:\u00a0str,task_input_kwargs:\u00a0Dict,auth:\u00a0Dict\u00a0=\u00a0None,headers:\u00a0List\u00a0=\u00a0None,**kwargs) -&gt; Any\n</code></pre> Process a request per device</p> <p><pre><code>run_global(self,result:\u00a0neops.core.provider.base.result.provider_result.ProviderResult,request_on:\u00a0str,mapping:\u00a0Dict,**kwargs) -&gt; Any\n</code></pre> Set common facts based on global request</p> <p><pre><code>run_on_device(self,task:\u00a0nornir.core.task.Task,device_id:\u00a0int,device_result:\u00a0neops.core.provider.base.result.coupled_provider_result_types.ProviderDeviceResult,request_on:\u00a0str,mapping:\u00a0Dict,task_input_kwargs:\u00a0Dict,**kwargs) -&gt; Any\n</code></pre> Set facts to device based on mapping template</p> <p><pre><code>run_on_device_group(self,device_group_id:\u00a0int,device_group_result:\u00a0neops.core.provider.base.result.coupled_provider_result_types.ProviderDeviceGroupResult,request_on:\u00a0str,mapping:\u00a0Dict,task_input_kwargs:\u00a0Dict,**kwargs) -&gt; Any\n</code></pre> Set facts to device group based on mapping template</p> <p><pre><code>run_on_interface(self,task:\u00a0nornir.core.task.Task,interface_id:\u00a0int,interface_result:\u00a0neops.core.provider.base.result.coupled_provider_result_types.ProviderInterfaceResult,request_on:\u00a0str,mapping:\u00a0Dict,task_input_kwargs:\u00a0Dict,**kwargs) -&gt; Any\n</code></pre> Set facts to interface based on mapping template</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_simple_workflow/","title":"neops.core.provider.generic_simple_workflow","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_simple_workflow/#genericsimpleworkflow","title":"GenericSimpleWorkflow","text":"<p>Provider to summarize other tasks.</p> <p>Every other task is called by its id or uniquetaskname, it has two templates on to set the entities on which the task is called and one to pass the input values.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_simple_workflow/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_simple_workflow/#excel-to-process-tasks","title":"Excel to Process Tasks","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_simple_workflow/#properties","title":"Properties","text":"<ul> <li> <p><code>run_as</code> (string): Select on which entity the task should run on. Must be one of: <code>['GLOBAL', 'GROUP', 'DEVICE', 'INTERFACE', 'CLIENT']</code>.</p> </li> <li> <p><code>tasks</code> (array): This description is used as a help message.</p> </li> <li> <p>Items (object)</p> <ul> <li> <p><code>titleProp</code> (string)</p> </li> <li> <p><code>run_as</code> (string): Select on which execute on entities will be passed to the task. Must be one of: <code>['GROUP', 'DEVICE', 'INTERFACE', 'CLIENT']</code>.</p> </li> <li> <p><code>allow_all</code> (boolean): some providers have the ability to run on all elements if there are none given, decide if this is fine for your task. Default: <code>False</code>.</p> </li> <li> <p><code>entity_template</code> (string): Get a List of Entity by the Template. Default: <code>{% set device_list = [] %} {% for device in neops.search_devices(\"devices.hostname: *.neops.io\") %} {{ device.hostname }} {% do device_list.append(device.id) %} {% endfor %} {% do neops.set_entities(device_list) %}</code>.</p> </li> <li> <p><code>task_id</code> (number): Set task id of task to process (set 0 if unique task name is used). Default: <code>0</code>.</p> </li> <li> <p><code>task_uniquename</code> (string): Set unique task name of task to process (task_id has priority).</p> </li> <li> <p><code>task_main</code> (boolean): Include pre and post run tasks in this step. Default: <code>True</code>.</p> </li> <li> <p><code>task_template</code> (string): Provide the data structure for the task input params. Default: <code>{% do neops.set_params({}) %}</code>.</p> </li> </ul> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_simple_workflow/#entity-and-params-templates","title":"Entity and Params Templates","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_simple_workflow/#entity-template","title":"Entity Template","text":"<p>A Jinja Template which is processed to select the entities where the task is applied on.</p> <p>The following parameters are passed to the template processing:</p> <ul> <li><code>input</code>: all inputs from the task run arguments</li> <li><code>elements</code>: the current selected objects based on <code>run_as</code> serialized as dictionary</li> <li><code>neops</code>: the neops object brings methods to access to other elements over the neops.io search and to save the facts objects<ul> <li><code>neops.search_devices(query)</code>: returns a list of devices found by the search query</li> <li><code>neops.search_interfaces(query)</code>: returns a list of interfaces found by the search query</li> <li><code>neops.search_device_groups(query)</code>: returns a list of groups found by the search query</li> <li><code>neops.search_client(query)</code>: returns a list of clients found by the search query</li> <li><code>neops.get_common_facts(key)</code>: returns the common/global fact of the given key</li> <li><code>neops.set_entities(ids)</code>: sets entities to run the task as list of ids</li> </ul> </li> </ul> <p>For more information on how to build a Jinja2 template, have a look at Appendix under Jinja2</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_simple_workflow/#params-template","title":"Params Template","text":"<p>A Jinja Template which is processed to pass the params to the task.</p> <p>The following parameters are passed to the template processing:</p> <ul> <li><code>input</code>: all inputs from the task run arguments</li> <li><code>entities</code>: ids of elements to run the task on</li> <li><code>elements</code>: entity objects serialized as dictionary</li> <li><code>neops</code>: the neops object brings methods to access to other elements over the neops.io search and to save the facts objects<ul> <li><code>neops.search_devices(query)</code>: returns a list of devices found by the search query</li> <li><code>neops.search_interfaces(query)</code>: returns a list of interfaces found by the search query</li> <li><code>neops.search_device_groups(query)</code>: returns a list of groups found by the search query</li> <li><code>neops.search_client(query)</code>: returns a list of clients found by the search query</li> <li><code>neops.get_common_facts(key)</code>: returns the common/global fact of the given key</li> <li><code>neops.set_params(dictionary)</code>: sets params as input values for the task</li> </ul> </li> </ul> <p>For more information on how to build a Jinja2 template, have a look at Appendix under Jinja2</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_simple_workflow/#methods","title":"Methods","text":"<p><pre><code>run_global(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,dry_run:\u00a0bool,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],search_query:\u00a0str,task_kwargs:\u00a0Dict[Any,\u00a0Any],result=neops.core.provider.base.result.provider_global_result.ProviderGlobalResult,**kwargs) -&gt; Any\n</code></pre> Process all subtasks</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_test_provider/","title":"neops.core.provider.generic_test_provider","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_test_provider/#module-functions","title":"Module functions","text":"<pre><code>test_failed_sub_task(task:\u00a0nornir.core.task.Task,res:\u00a0str,failed:\u00a0bool\u00a0=\u00a0False) -&gt; nornir.core.task.Result\n</code></pre>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_test_provider/#generictestprovider","title":"GenericTestProvider","text":"<p>The neops base provider contains all methods and required data processing for a concrete provider. To create a new provider, either extend this NeopsBaseProvider or a concrete provider</p> <p>the neops base provider is inherited from the BaseRunCycle</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_test_provider/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_test_provider/#interface-test-provider","title":"Interface Test Provider","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_test_provider/#properties","title":"Properties","text":"<ul> <li> <p><code>run_on</code> (string): Run Global or on Group, Device or Interface. Must be one of: <code>['GLOBAL', 'GROUP', 'DEVICE', 'INTERFACE', 'CLIENT']</code>.</p> </li> <li> <p><code>foo</code> (string): Foo Task Form Value.</p> </li> <li> <p><code>bar</code> (boolean): Bar Task Form Value.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_test_provider/#class-variables","title":"Class variables","text":"<pre><code>set_child_to_failed\n</code></pre>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_textfsm_facts/","title":"neops.core.provider.generic_textfsm_facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_textfsm_facts/#generictextfsmfacts","title":"GenericTextFSMFacts","text":"<p>Generic Provider to get facts from a show command parsed by TextFSM (but use v2 of this provider)</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_textfsm_facts/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_textfsm_facts/#add-structured-command-to-facts","title":"Add Structured Command to Facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_textfsm_facts/#properties","title":"Properties","text":"<ul> <li> <p><code>facts_key</code> (string): Set the key where the facts are saved.</p> </li> <li> <p><code>command</code> (string): Show command to convert to structured data.</p> </li> <li> <p><code>run_on</code> (string): Run on Group, Device or Interface. Must be one of: <code>['DEVICE', 'INTERFACE']</code>.</p> </li> <li> <p><code>add_facts_to</code> (string): Add Facts to Group, Device or Interface. Must be one of: <code>['GROUP', 'DEVICE', 'INTERFACE']</code>.</p> </li> <li> <p><code>jmes_param</code> (string): Add a JMES Path that can be uses as Param in the command.                 The $1 will be replaced by the content.                 For executing and parsing the command we expect a list.                 (access to device facts use facts. as initial key). Default: ``.</p> </li> <li> <p><code>jmes_interface</code> (string): Add a JMES Path to the interface name of the result for the mapping. Default: ``.</p> </li> <li> <p><code>textfsm</code> (string): TextFSM Template to parse the show output.</p> </li> <li> <p><code>slow_device</code> (integer): Add a factor for longer wait times for heavy loaded devices. Default: <code>0</code>.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_textfsm_facts_v2/","title":"neops.core.provider.generic_textfsm_facts_v2","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_textfsm_facts_v2/#generictextfsmfactsv2","title":"GenericTextFSMFactsV2","text":"<p>This Provider is used to get structured data from show commands from a device. The show command is executed on the device and the output is parsed by TextFSM.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_textfsm_facts_v2/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_textfsm_facts_v2/#add-structured-command-to-facts","title":"Add Structured Command to Facts","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_textfsm_facts_v2/#properties","title":"Properties","text":"<ul> <li> <p><code>facts_key</code> (string): Set the key where the facts are saved.</p> </li> <li> <p><code>add_facts_to</code> (string): Add Facts to Group, Device, Interface or Clients. Must be one of: <code>['GLOBAL', 'GROUP', 'DEVICE', 'INTERFACE', 'CLIENT']</code>.</p> </li> <li> <p><code>command_template</code> (string): Show command to convert to structured data(String is parsed by Jinja to create the command). Default: <code>show version</code>.</p> </li> <li> <p><code>textfsm_template</code> (string): TextFSM Template to parse the show output.</p> </li> <li> <p><code>mapping_template</code> (string): parse excel content (given as excel var to jinja) and provide the data structure for the task. Default: <code>{#### element props group, device, interface or client #} {#### command results are under the variable command_results #} {% do neops.set_facts(textfsm) %}</code>.</p> </li> <li> <p><code>slow_device</code> (integer): Add a factor for longer wait times for heavy loaded devices. Default: <code>0</code>.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_textfsm_facts_v2/#command-and-mapping-templates","title":"Command and Mapping Templates","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_textfsm_facts_v2/#command-template","title":"Command Template","text":"<p>A Jinja Template which is processed before applying the show command.</p> <p>The following parameters are passed to the template processing:</p> <ul> <li><code>input</code>: all inputs from the task run arguments</li> <li><code>elements</code>: ids of the affected elements based on add facts to selection</li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_textfsm_facts_v2/#mapping-template","title":"Mapping Template","text":"<p>A Jinja Template which is processed before apply the result of the TextFSM output to the facts.</p> <p>If the mapping template is empty (or only contains a space, because of the default value) the template is not proccessed and the output of the TextFSM output is directly saved to the facts.</p> <p>The following parameters are passed to the template processing:</p> <ul> <li><code>command_results</code>: _output from the TextFSM processing, if the facts are added to groups it is a list with the device id and result in a dictionary _</li> <li><code>device</code>: the current device object serialized as dictionary</li> <li><code>neops</code>: the neops object brings methods to access to other elements over the neops.io search and to save the facts objects<ul> <li><code>neops.search_devices(query)</code>: returns a list of devices found by the search query</li> <li><code>neops.search_interfaces(query)</code>: returns a list of interfaces found by the search query</li> <li><code>neops.search_device_groups(query)</code>: returns a list of groups found by the search query</li> <li><code>neops.search_client(query)</code>: returns a list of clients found by the search query</li> <li><code>neops.get_common_facts(key)</code>: returns the common/global fact of the given key</li> <li><code>neops.set_facts(dictionary)</code>: sets the facts to be saved</li> </ul> </li> </ul> <p>For more information on how to build a Jinja2 template, have a look at Appendix under Jinja2</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.generic_textfsm_facts_v2/#methods","title":"Methods","text":"<p><pre><code>pre_run_on_nornir_device(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,task_kwargs:\u00a0Dict[Any,\u00a0Any],task:\u00a0nornir.core.task.Task,nornir_device_id:\u00a0int,**kwargs) -&gt; Any\n</code></pre> Processes the command Jinja template and executes the show command on the device</p> <p><pre><code>run_global(self,task_kwargs:\u00a0Dict[Any,\u00a0Any],**kwargs) -&gt; Union[Dict[Any,\u00a0Any],\u00a0NoneType]\n</code></pre> Processes the output and the mapping template if the \"add facts to\" is set to GLOBAL</p> <p><pre><code>run_on_client_of_interface(self,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],task_kwargs:\u00a0Dict[Any,\u00a0Any],task:\u00a0nornir.core.task.Task,nornir_device_id:\u00a0int,device_id:\u00a0int,interface_id:\u00a0int,client_id:\u00a0int,client_result:\u00a0neops.core.provider.base.result.coupled_provider_result_types.ProviderClientResult,**kwargs) -&gt; Any\n</code></pre> Processes the output and the mapping template if the \"add facts to\" is set to CLIENT</p> <p><pre><code>run_on_device(self,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],task_kwargs:\u00a0Dict[Any,\u00a0Any],task:\u00a0nornir.core.task.Task,nornir_device_id:\u00a0int,device_id:\u00a0int,device_result:\u00a0neops.core.provider.base.result.coupled_provider_result_types.ProviderDeviceResult,**kwargs) -&gt; Any\n</code></pre> Processes the output and the mapping template if the \"add facts to\" is set to DEVICE</p> <p><pre><code>run_on_device_group(self,device_group_id:\u00a0int,task_kwargs:\u00a0Dict[Any,\u00a0Any],device_group_result:\u00a0neops.core.provider.base.result.coupled_provider_result_types.ProviderDeviceGroupResult,**kwargs) -&gt; Union[Dict[Any,\u00a0Any],\u00a0NoneType]\n</code></pre> Processes the output and the mapping template if the \"add facts to\" is set to GROUP</p> <p><pre><code>run_on_interface(self,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],task_kwargs:\u00a0Dict[Any,\u00a0Any],task:\u00a0nornir.core.task.Task,nornir_device_id:\u00a0int,device_id:\u00a0int,interface_id:\u00a0int,interface_result:\u00a0neops.core.provider.base.result.coupled_provider_result_types.ProviderInterfaceResult,**kwargs) -&gt; Any\n</code></pre> Processes the output and the mapping template if the \"add facts to\" is set to INTERFACE</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.global_mail/","title":"neops.core.provider.global_mail","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.global_mail/#globalmail","title":"GlobalMail","text":"<p>Send email notification</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.global_mail/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.global_mail/#mail","title":"Mail","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.global_mail/#properties","title":"Properties","text":"<ul> <li> <p><code>include_executor</code> (boolean): Add the task executor to the list to recipients. Default: <code>False</code>.</p> </li> <li> <p><code>mail_to</code> (string): recipients email addresses comma separated. Default: ``.</p> </li> <li> <p><code>title</code> (string): Process Jinja template to set email title. Default: ``.</p> </li> <li> <p><code>body</code> (string): Process Jinja template to set email body. Default: ``.</p> </li> <li> <p><code>as_attachment</code> (string): Process Jinja template to send infomarations as email attachment. Default: ``.</p> </li> <li> <p><code>attachment_name</code> (string): name of the attachment. Default: ``.</p> </li> <li> <p><code>zip_attachment</code> (boolean): should we compress the attachment. Default: <code>False</code>.</p> </li> <li> <p><code>mail_from</code> (string): set the from address of the email. Default: ``.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.global_mail/#templates","title":"Templates","text":"<p>Jinja Template options for processing email title, body and attachment</p> <p>The following parameters are passed to the template processing:</p> <ul> <li><code>input</code>: all inputs from the task run arguments</li> <li><code>execution</code>: the current execution information serialized as dictionary</li> <li><code>neops</code>: the neops object brings methods to access to other elements over the neops.io search<ul> <li><code>neops.search_devices(query)</code>: returns a list of devices found by the search query</li> <li><code>neops.search_interfaces(query)</code>: returns a list of interfaces found by the search query</li> <li><code>neops.search_device_groups(query)</code>: returns a list of groups found by the search query</li> <li><code>neops.search_client(query)</code>: returns a list of clients found by the search query</li> <li><code>neops.get_common_facts(key)</code>: returns the common/global fact of the given key</li> </ul> </li> </ul> <p>For more information on how to build a Jinja2 template, have a look at Appendix under Jinja2</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.global_mail/#methods","title":"Methods","text":"<p><pre><code>run_global(self,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,dry_run:\u00a0bool,task_input_kwargs:\u00a0Dict[Any,\u00a0Any],search_query:\u00a0str,task_kwargs:\u00a0Dict[Any,\u00a0Any],result,**kwargs) -&gt; Any\n</code></pre> Process template and send email</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.interface_configure_from_jinja/","title":"neops.core.provider.interface_configure_from_jinja","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.interface_configure_from_jinja/#interfacejinjaconfigureprovider","title":"InterfaceJinjaConfigureProvider","text":"<p>Provider to configure a device based on the passed interface selection to a jinja template</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.interface_configure_from_jinja/#interface-configure-parameters","title":"Interface Configure Parameters","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.interface_configure_from_jinja/#template","title":"Template","text":"<p>A Jinja Template which is processed before apply the result of this template to the device.</p> <p>The following parameters are passed to the template processing:</p> <ul> <li><code>input</code>: all inputs from the task run arguments</li> <li><code>device</code>: the current device object serialized as dictionary</li> <li><code>interfaces</code>: the current selected interface objects serialized as dictionary</li> <li><code>neops</code>: the neops object brings methods to access to other elements over the neops.io search<ul> <li><code>neops.search_devices(query)</code>: returns a list of devices found by the search query</li> <li><code>neops.search_interfaces(query)</code>: returns a list of interfaces found by the search query</li> <li><code>neops.search_device_groups(query)</code>: returns a list of groups found by the search query</li> <li><code>neops.search_client(query)</code>: returns a list of clients found by the search query</li> <li><code>neops.get_common_facts(key)</code>: returns the common/global fact of the given key</li> </ul> </li> </ul> <p>For more information on how to build a Jinja2 template, have a look at Appendix under Jinja2</p> <p>Example of device and neops usage (only to show usage, config change doesn't make sense): <pre><code>hostname {{ device.hostname }}\n\n{% for interface in interfaces %}\ninterface {{ interface.name }}\n  description NEW-DESCRIPTION\n{% endfor %}\n</code></pre></p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.interface_configure_from_jinja/#global-base-configure-parameters","title":"Global Base Configure Parameters","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.interface_configure_from_jinja/#apply-method","title":"Apply Method","text":"<p>The apply method descripbes how the configuration is written to the device.</p> <ul> <li><code>cli</code>: the configuration is applied directly in the configration mode</li> <li><code>scp</code>: the configuration is copied (with scp) as a file to the device and applied with an merge operation</li> <li><code>scp-startup</code>: the configuration is copied (with scp) as a file to the device and written to the start up configuration</li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.interface_configure_from_jinja/#slow-devices","title":"Slow Devices","text":"<p>With the <code>slow_device</code> parameter you can specify a delay factor to wait a longer time on responses from             slow devices</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.interface_configure_from_jinja/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.interface_configure_from_jinja/#interface-configuration","title":"Interface Configuration","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.interface_configure_from_jinja/#properties","title":"Properties","text":"<ul> <li> <p><code>apply</code> (string): Method how to apply the configuration, over cli or copy with scp and merge. Must be one of: <code>['scp', 'cli', 'scp-startup']</code>.</p> </li> <li> <p><code>slow_device</code> (integer): Add a factor for longer wait times for heavy loaded devices. Default: <code>0</code>.</p> </li> <li> <p><code>template</code> (string): Jinja Template to generate the configuration.</p> </li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.interface_configure_from_jinja/#methods","title":"Methods","text":"<p><pre><code>run_on_device(self,task:\u00a0nornir.core.task.Task,device_id:\u00a0int,execute_on:\u00a0List[int],execute_on_type:\u00a0neops.core.provider.base.enum.RunOnEnum,**kwargs) -&gt; nornir.core.task.Result\n</code></pre> Process the template and apply the configuration to the device</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.interface_rollback/","title":"neops.core.provider.interface_rollback","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.interface_rollback/#interfacerollbackprovider","title":"InterfaceRollbackProvider","text":"<p>The neops base provider contains all methods and required data processing for a concrete provider. To create a new provider, either extend this NeopsBaseProvider or a concrete provider</p> <p>the neops base provider is inherited from the BaseRunCycle</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.interface_rollback/#json-schema","title":"JSON Schema","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.interface_rollback/#configure-base-provider","title":"Configure Base Provider","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.interface_rollback/#properties","title":"Properties","text":"<ul> <li><code>apply</code> (string): Method how to apply the configuration, over cli or copy with scp and merge. Must be one of: <code>['scp', 'cli']</code>. Default: <code>cli</code>.</li> </ul>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider/","title":"neops.core.provider","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.registry/","title":"neops.core.provider.registry","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.registry/#module-functions","title":"Module functions","text":"<p><pre><code>get_provider(name:\u00a0str) -&gt; Union[Dict,\u00a0NoneType]\n</code></pre> <pre><code>get_providers() -&gt; \n</code></pre> <pre><code>register_provider(cls) -&gt; \n</code></pre> Register a neops provider. Tasks can be registered for specific vendors and (also optional) specific models. This decorator only adds a marker attribute on the function, the provider_loader.load_providers function builds the actual registry. This way we can enforce the correct order of the tasks (default builtin neops providers, after that all tasks loaded from the NEOPS_PROVIDER_MODULES), and do not depend on the import order of the modules.</p>"},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.registry.provider_loader/","title":"neops.core.provider.registry.provider_loader","text":""},{"location":"legacy/Neops%20Provider%20Overview/neops.core.provider.registry.provider_loader/#module-functions","title":"Module functions","text":"<pre><code>load_providers() -&gt; \n</code></pre>"},{"location":"make_scripts/mkdocs-documentation/docs_template/","title":"Your project documentation","text":""},{"location":"make_scripts/mkdocs-documentation/docs_template/#next-steps","title":"Next steps","text":"<p>If you want to include this documentation as a sub-documentation in another repository, add the following line to the <code>mkdocs_custom.yml</code> of the other repository.</p> <pre><code>cd submodules\ngit submodule add your-repo-name\n</code></pre> <pre><code>- Your project documentation: '!include ./submodules/your-repo-name/mkdocs.yml'\n</code></pre>"},{"location":"make_scripts/mkdocs-documentation/docs_template/#reference","title":"Reference","text":"<ul> <li>Markdown/Material for MkDocs</li> <li>Usage of Snippets</li> </ul>"},{"location":"neops-gql-gtw/","title":"Neops Secure Gateway","text":""},{"location":"neops-gql-gtw/#description","title":"Description","text":"<p>This is a GraphQL gateway for the Neops project. It is a proxy that provides a single endpoint for all the graphql services in the Neops project.</p> <p>It can be used to transform the schema that is served to the client, as well as to modify the data that is returned from queries and mutations. The configuration is done using environment variables (check <code>docker-compose.yml</code>) and a configuration file (check <code>config/example-rules.json</code>). The gateway is designed to be used to prevent 3rd party systems from accessing sensitive data, starting processes, running reports, or accessing data structures exposed by the Neops Graphql API.</p>"},{"location":"neops-gql-gtw/#docs","title":"Docs","text":"<p>For more information about the projects underlying concepts, please refer to the documentation.</p>"},{"location":"neops-gql-gtw/#development","title":"Development","text":"<p>The project is built using NestJS and GraphQL. Setup for development is done using NodeJs, Docker and Docker Compose.</p>"},{"location":"neops-gql-gtw/#prerequisites","title":"Prerequisites","text":"<ul> <li>Node.js &gt;= 20.x</li> <li>Docker (for running the Neops Graphql API)</li> <li>Running Neops Graphql API (for testing the gateway)</li> </ul>"},{"location":"neops-gql-gtw/#install-dependencies","title":"Install dependencies","text":"<pre><code>$ npm install\n</code></pre>"},{"location":"neops-gql-gtw/#building-the-app","title":"Building the app","text":"<pre><code>$ npm run build\n</code></pre>"},{"location":"neops-gql-gtw/#running-the-app","title":"Running the app","text":"<pre><code># development with debugger\n$ npm run start:debug\n\n# watch mode\n$ npm run start:dev\n\n# production mode\n$ npm run start:prod\n</code></pre>"},{"location":"neops-gql-gtw/#test","title":"Test","text":"<pre><code># unit tests\n$ npm run test\n\n# e2e tests\n$ npm run test:e2e\n\n# test coverage\n$ npm run test:cov\n</code></pre>"},{"location":"neops-gql-gtw/pull_request_template/","title":"Description","text":"<p>Please include a short summary of the changes here.</p>"},{"location":"neops-gql-gtw/pull_request_template/#checklist","title":"Checklist:","text":"<ul> <li>[ ] PR label has been set</li> <li>[ ] My code follows the style guidelines of this project</li> <li>[ ] I have commented my code, particularly in hard-to-understand areas</li> <li>[ ] My changes generate no new warnings</li> </ul>"},{"location":"neops-gql-gtw/docs/","title":"Neops Secure Gateway","text":""},{"location":"neops-gql-gtw/docs/#concepts","title":"Concepts","text":""},{"location":"neops-gql-gtw/docs/#role-in-the-neops-eco-system","title":"Role in the Neops Eco-System","text":"<p>The gateway acts as a single endpoint for all the Graphql Operations of a running Neops Backend Graphql API. It can be used to transform the schema that is served to the client, as well as to modify the data that is served to the client. This can be used to filter out sensitive data, or to restrict the operations that the client can perform. Typically it is used to expose / restrict the Graphql API from a secure network to an insecure network.</p>"},{"location":"neops-gql-gtw/docs/#big-picture","title":"Big Picture","text":"<pre><code>graph TD\n    %% Top-level: Public Network\n    subgraph Public_Insecure_Network[\"` **Public Network** `\"]\n        E1[Neops Dashboard]\n        E2[Enterprise Integration]\n        E3[Process Monitoring]\n    end\n\n    %% Middle-layer: Secure Gateway with Restrictions\n    subgraph Secure_Gateway[\"\"` **Secure Gateway** `\"\"]\n        direction TB\n        G1[filter out credentials] ~~~ G2[deny certain task executions] ~~~ G3[deny reports executions] ~~~ G4[deny mutations]\n        G5[hide all device details] ~~~ G6[show certain facts] ~~~ G7[deny task execution] ~~~ G8[allow only check data]\n    end\n\n    %% Bottom-level: Managed Network\n    subgraph Corporate_Managed_Network[\"\"` **Managed Network** `\"\"]\n        C[Neops Backend GQL API]\n    end\n\n    %% Connections\n\n\n    Public_Insecure_Network --- Secure_Gateway\n    Secure_Gateway --- Corporate_Managed_Network\n\n\n    %% Apply Styles\n    classDef redBox stroke:#FF0000,stroke-width:2px;\n    classDef blueBox stroke:#0000FF,stroke-width:2px;\n    classDef greenBox stroke:#008000,stroke-width:2px;\n\n    class E1,E2,E3 redBox;\n    class G1,G2,G3,G4,G5,G6,G7,G8 blueBox;\n    class C greenBox;\n</code></pre>"},{"location":"neops-gql-gtw/docs/#features","title":"Features","text":"<p>Context of all features is the gateway acting as endpoint for all Graphql Operations within insecure networks to prevent 3rd party systems of accessing sensitive data, start processes and run reports or accessing device credentials.</p>"},{"location":"neops-gql-gtw/docs/#schema-transformation","title":"Schema transformation","text":"<p>Having the ability to transform the schema that is served to the client, allows to restrict the operations that the client can perform.</p> <p>A Graphql Operation is a query, mutation or subscription. The schema transformation can be used to allow or deny specific operations. It is possible to configure a list of allowed and denied operations. If a operation is allowed, all other operations are denied. If a operation is denied, all other operations are allowed.</p> <p>See below for an example configuration.</p>"},{"location":"neops-gql-gtw/docs/#data-transformation-resolvers","title":"Data transformation / Resolvers","text":"<p>Schema Transformations modify the schema that is served to the client. Resolvers affect the data that is served to the client during runtime of the Graphql Operation. This can be used to filter out sensitive data, or to restrict the operations that the client can perform according to configured rules.</p> <p>See below for an example configuration.</p>"},{"location":"neops-gql-gtw/docs/#task-and-report-filtering","title":"Task and Report filtering","text":"<p>To ensure certain Tasks or Export can not be called, the gateway can be configured to allow or deny specific tasks and reports. Reports / Task filters are a specialized form of the Resolvers and act during runtime of the Graphql Operation and permit or deny the execution of specific tasks or reports the client is requesting to do so.</p>"},{"location":"neops-gql-gtw/docs/#configuration","title":"Configuration","text":""},{"location":"neops-gql-gtw/docs/#environment-variables","title":"Environment variables","text":"<p>Ensure to set the following environment variables (the values here are just examples) for the environemnt you are running the gateway in:</p> <pre><code>PORT=1234\nPATH_TO_RULES=config/example-rules.json\nGRAPHQL_ENDPOINT_NEOPS=http://localhost:8000/graphql\nSTATIC_AUTH_TOKEN=\"Bearer your-token\"\n</code></pre>"},{"location":"neops-gql-gtw/docs/#configuration-rules","title":"Configuration Rules","text":""},{"location":"neops-gql-gtw/docs/#schema-transformation_1","title":"Schema transformation","text":"<p>check the example file under <code>config/example-rules.json</code> to see how to configure the rules for the gateway.</p> <p>To modify/transform the schema itself prior to serve the graphql endpoint, one can allow or deny certain operations. This directly modifies the schema which will be served to accessing clients.</p> <p><code>operationAllow</code> will allow the execution of specific operations by the client and deny all others. An empty list, will ALLOW all operations.</p> <p><code>operationDeny</code> will deny the execution of specific operations by the client. Example:</p> <pre><code>{\n  \"transformers\": {\n    \"operationAllow\": [],\n    \"operationDeny\": [\n      { \"operationName\": \"Query\", \"fieldName\": \"interfacesElastic\" }\n    ]\n  }\n}\n</code></pre>"},{"location":"neops-gql-gtw/docs/#data-transformation-resolvers_1","title":"Data transformation / Resolvers","text":"<p>Configuring resolvers gives ou access to the data that is served by the gateway.</p> <p><code>valueErasers</code> will remove the value (set to null) of a field from the response. This is useful for sensitive data that should not be exposed to the client.</p> <p><code>tasksAllow</code> will allow the execution of specific tasks by the client and deny all others. An empty list, will DENY all tasks.</p> <p><code>tasksDeny</code> will deny the execution of specific tasks by the client.</p> <p><code>reportsAllow</code> will allow the execution of specific reports by the client and deny all others. An empty list, will DENY all reports.</p> <p><code>reportsDeny</code> will deny the execution of specific reports by the client.</p> <p><code>jsonData</code> will allow or deny the population of specific json attributes of a specific field in the response. it can be an array of strings which represent json strings like <code>[\"config.version\", \"config.user\"]</code> or a regex path which describes allowed or denied object or array structures. See example below.</p> <p>Example:</p> <pre><code>{\n  \"transformers\": {\n    \"operationAllow\": [],\n    \"operationDeny\": [\n      { \"operationName\": \"Query\", \"fieldName\": \"interfacesElastic\" }\n    ]\n  },\n  \"resolvers\": {\n    \"valueErasers\": [\n      {\n        \"fieldName\": \"username\",\n        \"typeName\": \"DeviceType\"\n      },\n      {\n        \"fieldName\": \"hostname\",\n        \"typeName\": \"DeviceType\"\n      }\n    ],\n    \"jsonData\": [\n      {\n        \"typeName\": \"DeviceType\",\n        \"fieldName\": \"checks\",\n        \"allow\": [\"device.available\"],\n        \"deny\": null\n      },\n      {\n        \"typeName\": \"DeviceType\",\n        \"fieldName\": \"facts\",\n        \"allow\": \"^location\\\\.devices\\\\[\\\\d+\\\\]\\\\.interfaces\\\\[\\\\d+\\\\]\\\\.name$\",\n        \"deny\": null\n      }\n    ],\n    \"tasksAllow\": null,\n    \"tasksDeny\": [],\n    \"reportsAllow\": [\n      {\n        \"uniqueTaskName\": \"super.awesome.report\"\n      }\n    ],\n    \"reportsDeny\": [\n      {\n        \"uniqueTaskName\": \"super.awesome.report\"\n      }\n    ]\n  }\n}\n</code></pre> <p>to use the rules then in a docker container, you need to mount the file to the container:</p> <pre><code>services:\n  gqlgateway:\n    build: .\n    env_file:\n      - .env\n    volumes:\n      - ./config/rules.json:/app/config/rules.json\n</code></pre>"},{"location":"neops-gql-gtw/docs/dir/architecture/","title":"Architecture","text":"<pre><code>graph TD\n    %% Top-level: Public Network\n    subgraph Public_Insecure_Network[\"` **Public Network** `\"]\n        E1[Neops Dashboard]\n        E2[Enterprise Integration]\n        E3[Process Monitoring]\n    end\n\n    %% Middle-layer: Secure Gateway with Restrictions\n    subgraph Secure_Gateway[\"\"` **Secure Gateway** `\"\"]\n        direction TB\n        G1[filter out credentials] ~~~ G2[deny certain task executions] ~~~ G3[deny reports executions] ~~~ G4[deny mutations]\n        G5[hide all device details] ~~~ G6[show certain facts] ~~~ G7[deny task execution] ~~~ G8[allow only check data]\n    end\n\n    %% Bottom-level: Managed Network\n    subgraph Corporate_Managed_Network[\"\"` **Managed Network** `\"\"]\n        C[Neops Backend GQL API]\n    end\n\n    %% Connections\n\n\n    Public_Insecure_Network --- Secure_Gateway\n    Secure_Gateway --- Corporate_Managed_Network\n\n\n    %% Apply Styles\n    classDef redBox stroke:#FF0000,stroke-width:2px;\n    classDef blueBox stroke:#0000FF,stroke-width:2px;\n    classDef greenBox stroke:#008000,stroke-width:2px;\n\n    class E1,E2,E3 redBox;\n    class G1,G2,G3,G4,G5,G6,G7,G8 blueBox;\n    class C greenBox;\n</code></pre>"},{"location":"neops-gql-gtw/docs/make_scripts/mkdocs-documentation/docs_template/","title":"Your project documentation","text":""},{"location":"neops-gql-gtw/docs/make_scripts/mkdocs-documentation/docs_template/#next-steps","title":"Next steps","text":"<p>If you want to include this documentation as a sub-documentation in another repository, add the following line to the <code>mkdocs_custom.yml</code> of the other repository.</p> <pre><code>cd submodules\ngit submodule add your-repo-name\n</code></pre> <pre><code>- Your project documentation: '!include ./submodules/your-repo-name/mkdocs.yml'\n</code></pre>"},{"location":"neops-gql-gtw/docs/make_scripts/mkdocs-documentation/docs_template/#reference","title":"Reference","text":"<ul> <li>Markdown/Material for MkDocs</li> <li>Usage of Snippets</li> </ul>"},{"location":"neops-gql-gtw/make_scripts/mkdocs-documentation/docs_template/","title":"Your project documentation","text":""},{"location":"neops-gql-gtw/make_scripts/mkdocs-documentation/docs_template/#next-steps","title":"Next steps","text":"<p>If you want to include this documentation as a sub-documentation in another repository, add the following line to the <code>mkdocs_custom.yml</code> of the other repository.</p> <pre><code>cd submodules\ngit submodule add your-repo-name\n</code></pre> <pre><code>- Your project documentation: '!include ./submodules/your-repo-name/mkdocs.yml'\n</code></pre>"},{"location":"neops-gql-gtw/make_scripts/mkdocs-documentation/docs_template/#reference","title":"Reference","text":"<ul> <li>Markdown/Material for MkDocs</li> <li>Usage of Snippets</li> </ul>"},{"location":"neops-graphql-docs/","title":"Your project documentation","text":""},{"location":"neops-graphql-docs/#next-steps","title":"Next steps","text":"<p>If you want to include this documentation as a sub-documentation in another repository, add the following line to the <code>mkdocs_custom.yml</code> of the other repository.</p> <pre><code>cd submodules\ngit submodule add your-repo-name\n</code></pre> <pre><code>- Your project documentation: '!include ./submodules/your-repo-name/mkdocs.yml'\n</code></pre>"},{"location":"neops-graphql-docs/#reference","title":"Reference","text":"<ul> <li>Markdown/Material for MkDocs: https://squidfunk.github.io/mkdocs-material/reference/</li> <li>Snippets: https://facelessuser.github.io/pymdown-extensions/extensions/snippets/</li> </ul>"},{"location":"neops-secure-gateway-docs/","title":"Neops Secure Gateway","text":""},{"location":"neops-secure-gateway-docs/#concepts","title":"Concepts","text":""},{"location":"neops-secure-gateway-docs/#role-in-the-neops-eco-system","title":"Role in the Neops Eco-System","text":"<p>The gateway acts as a single endpoint for all the Graphql Operations of a running Neops Backend Graphql API. It can be used to transform the schema that is served to the client, as well as to modify the data that is served to the client. This can be used to filter out sensitive data, or to restrict the operations that the client can perform. Typically it is used to expose / restrict the Graphql API from a secure network to an insecure network.</p>"},{"location":"neops-secure-gateway-docs/#big-picture","title":"Big Picture","text":"<pre><code>graph TD\n    %% Top-level: Public Network\n    subgraph Public_Insecure_Network[\"` **Public Network** `\"]\n        E1[Neops Dashboard]\n        E2[Enterprise Integration]\n        E3[Process Monitoring]\n    end\n\n    %% Middle-layer: Secure Gateway with Restrictions\n    subgraph Secure_Gateway[\"\"` **Secure Gateway** `\"\"]\n        direction TB\n        G1[filter out credentials] ~~~ G2[deny certain task executions] ~~~ G3[deny reports executions] ~~~ G4[deny mutations]\n        G5[hide all device details] ~~~ G6[show certain facts] ~~~ G7[deny task execution] ~~~ G8[allow only check data]\n    end\n\n    %% Bottom-level: Managed Network\n    subgraph Corporate_Managed_Network[\"\"` **Managed Network** `\"\"]\n        C[Neops Backend GQL API]\n    end\n\n    %% Connections\n\n\n    Public_Insecure_Network --- Secure_Gateway\n    Secure_Gateway --- Corporate_Managed_Network\n\n\n    %% Apply Styles\n    classDef redBox stroke:#FF0000,stroke-width:2px;\n    classDef blueBox stroke:#0000FF,stroke-width:2px;\n    classDef greenBox stroke:#008000,stroke-width:2px;\n\n    class E1,E2,E3 redBox;\n    class G1,G2,G3,G4,G5,G6,G7,G8 blueBox;\n    class C greenBox;\n</code></pre>"},{"location":"neops-secure-gateway-docs/#features","title":"Features","text":"<p>Context of all features is the gateway acting as endpoint for all Graphql Operations within insecure networks to prevent 3rd party systems of accessing sensitive data, start processes and run reports or accessing device credentials.</p>"},{"location":"neops-secure-gateway-docs/#schema-transformation","title":"Schema transformation","text":"<p>Having the ability to transform the schema that is served to the client, allows to restrict the operations that the client can perform.</p> <p>A Graphql Operation is a query, mutation or subscription. The schema transformation can be used to allow or deny specific operations. It is possible to configure a list of allowed and denied operations. If a operation is allowed, all other operations are denied. If a operation is denied, all other operations are allowed.</p> <p>See below for an example configuration.</p>"},{"location":"neops-secure-gateway-docs/#data-transformation-resolvers","title":"Data transformation / Resolvers","text":"<p>Schema Transformations modify the schema that is served to the client. Resolvers affect the data that is served to the client during runtime of the Graphql Operation. This can be used to filter out sensitive data, or to restrict the operations that the client can perform according to configured rules.</p> <p>See below for an example configuration.</p>"},{"location":"neops-secure-gateway-docs/#task-and-report-filtering","title":"Task and Report filtering","text":"<p>To ensure certain Tasks or Export can not be called, the gateway can be configured to allow or deny specific tasks and reports. Reports / Task filters are a specialized form of the Resolvers and act during runtime of the Graphql Operation and permit or deny the execution of specific tasks or reports the client is requesting to do so.</p>"},{"location":"neops-secure-gateway-docs/#configuration","title":"Configuration","text":""},{"location":"neops-secure-gateway-docs/#environment-variables","title":"Environment variables","text":"<p>Ensure to set the following environment variables (the values here are just examples) for the environemnt you are running the gateway in:</p> <pre><code>PORT=1234\nPATH_TO_RULES=config/example-rules.json\nGRAPHQL_ENDPOINT_NEOPS=http://localhost:8000/graphql\nSTATIC_AUTH_TOKEN=\"Bearer your-token\"\n</code></pre>"},{"location":"neops-secure-gateway-docs/#configuration-rules","title":"Configuration Rules","text":""},{"location":"neops-secure-gateway-docs/#schema-transformation_1","title":"Schema transformation","text":"<p>check the example file under <code>config/example-rules.json</code> to see how to configure the rules for the gateway.</p> <p>To modify/transform the schema itself prior to serve the graphql endpoint, one can allow or deny certain operations. This directly modifies the schema which will be served to accessing clients.</p> <p><code>operationAllow</code> will allow the execution of specific operations by the client and deny all others. An empty list, will ALLOW all operations.</p> <p><code>operationDeny</code> will deny the execution of specific operations by the client. Example:</p> <pre><code>{\n  \"transformers\": {\n    \"operationAllow\": [],\n    \"operationDeny\": [\n      { \"operationName\": \"Query\", \"fieldName\": \"interfacesElastic\" }\n    ]\n  }\n}\n</code></pre>"},{"location":"neops-secure-gateway-docs/#data-transformation-resolvers_1","title":"Data transformation / Resolvers","text":"<p>Configuring resolvers gives ou access to the data that is served by the gateway.</p> <p><code>valueErasers</code> will remove the value (set to null) of a field from the response. This is useful for sensitive data that should not be exposed to the client.</p> <p><code>tasksAllow</code> will allow the execution of specific tasks by the client and deny all others. An empty list, will DENY all tasks.</p> <p><code>tasksDeny</code> will deny the execution of specific tasks by the client.</p> <p><code>reportsAllow</code> will allow the execution of specific reports by the client and deny all others. An empty list, will DENY all reports.</p> <p><code>reportsDeny</code> will deny the execution of specific reports by the client.</p> <p><code>jsonData</code> will allow or deny the population of specific json attributes of a specific field in the response. it can be an array of strings which represent json strings like <code>[\"config.version\", \"config.user\"]</code> or a regex path which describes allowed or denied object or array structures. See example below.</p> <p>Example:</p> <pre><code>{\n  \"transformers\": {\n    \"operationAllow\": [],\n    \"operationDeny\": [\n      { \"operationName\": \"Query\", \"fieldName\": \"interfacesElastic\" }\n    ]\n  },\n  \"resolvers\": {\n    \"valueErasers\": [\n      {\n        \"fieldName\": \"username\",\n        \"typeName\": \"DeviceType\"\n      },\n      {\n        \"fieldName\": \"hostname\",\n        \"typeName\": \"DeviceType\"\n      }\n    ],\n    \"jsonData\": [\n      {\n        \"typeName\": \"DeviceType\",\n        \"fieldName\": \"checks\",\n        \"allow\": [\"device.available\"],\n        \"deny\": null\n      },\n      {\n        \"typeName\": \"DeviceType\",\n        \"fieldName\": \"facts\",\n        \"allow\": \"^location\\\\.devices\\\\[\\\\d+\\\\]\\\\.interfaces\\\\[\\\\d+\\\\]\\\\.name$\",\n        \"deny\": null\n      }\n    ],\n    \"tasksAllow\": null,\n    \"tasksDeny\": [],\n    \"reportsAllow\": [\n      {\n        \"uniqueTaskName\": \"super.awesome.report\"\n      }\n    ],\n    \"reportsDeny\": [\n      {\n        \"uniqueTaskName\": \"super.awesome.report\"\n      }\n    ]\n  }\n}\n</code></pre> <p>to use the rules then in a docker container, you need to mount the file to the container:</p> <pre><code>services:\n  gqlgateway:\n    build: .\n    env_file:\n      - .env\n    volumes:\n      - ./config/rules.json:/app/config/rules.json\n</code></pre>"},{"location":"neops-secure-gateway-docs/dir/architecture/","title":"Architecture","text":"<pre><code>graph TD\n    %% Top-level: Public Network\n    subgraph Public_Insecure_Network[\"` **Public Network** `\"]\n        E1[Neops Dashboard]\n        E2[Enterprise Integration]\n        E3[Process Monitoring]\n    end\n\n    %% Middle-layer: Secure Gateway with Restrictions\n    subgraph Secure_Gateway[\"\"` **Secure Gateway** `\"\"]\n        direction TB\n        G1[filter out credentials] ~~~ G2[deny certain task executions] ~~~ G3[deny reports executions] ~~~ G4[deny mutations]\n        G5[hide all device details] ~~~ G6[show certain facts] ~~~ G7[deny task execution] ~~~ G8[allow only check data]\n    end\n\n    %% Bottom-level: Managed Network\n    subgraph Corporate_Managed_Network[\"\"` **Managed Network** `\"\"]\n        C[Neops Backend GQL API]\n    end\n\n    %% Connections\n\n\n    Public_Insecure_Network --- Secure_Gateway\n    Secure_Gateway --- Corporate_Managed_Network\n\n\n    %% Apply Styles\n    classDef redBox stroke:#FF0000,stroke-width:2px;\n    classDef blueBox stroke:#0000FF,stroke-width:2px;\n    classDef greenBox stroke:#008000,stroke-width:2px;\n\n    class E1,E2,E3 redBox;\n    class G1,G2,G3,G4,G5,G6,G7,G8 blueBox;\n    class C greenBox;\n</code></pre>"},{"location":"neops-secure-gateway-docs/make_scripts/mkdocs-documentation/docs_template/","title":"Your project documentation","text":""},{"location":"neops-secure-gateway-docs/make_scripts/mkdocs-documentation/docs_template/#next-steps","title":"Next steps","text":"<p>If you want to include this documentation as a sub-documentation in another repository, add the following line to the <code>mkdocs_custom.yml</code> of the other repository.</p> <pre><code>cd submodules\ngit submodule add your-repo-name\n</code></pre> <pre><code>- Your project documentation: '!include ./submodules/your-repo-name/mkdocs.yml'\n</code></pre>"},{"location":"neops-secure-gateway-docs/make_scripts/mkdocs-documentation/docs_template/#reference","title":"Reference","text":"<ul> <li>Markdown/Material for MkDocs</li> <li>Usage of Snippets</li> </ul>"},{"location":"neops-task-engine-docs/","title":"Your project documentation","text":""},{"location":"neops-task-engine-docs/#next-steps","title":"Next steps","text":"<p>If you want to include this documentation as a sub-documentation in another repository, add the following line to the <code>mkdocs_custom.yml</code> of the other repository.</p> <pre><code>cd submodules\ngit submodule add your-repo-name\n</code></pre> <pre><code>- Your project documentation: '!include ./submodules/your-repo-name/mkdocs.yml'\n</code></pre>"},{"location":"neops-task-engine-docs/#reference","title":"Reference","text":"<ul> <li>Markdown/Material for MkDocs: https://squidfunk.github.io/mkdocs-material/reference/</li> <li>Snippets: https://facelessuser.github.io/pymdown-extensions/extensions/snippets/</li> </ul>"},{"location":"neops-task-engine-docs/concept/context/","title":"Context","text":"<p>A context in a workflow typically represents the current state of knowledge that is available at any point during the execution. It holds all relevant information gathered throughout the workflow.</p> <ul> <li>Dynamic Population: The context is initially populated during the acquisition phase, where selected entities, static and dynamic acquisition processes contribute to the information in the context.</li> <li>Entity Inclusion: Only static or dynamic acquired entities are included in the context. No automatic resolving of entities is done. This controlled setup ensures only relevant data is present.</li> <li>Updates with Function Block Results: As the workflow progresses, results generated by different function blocks are also added to the context. This allows the context to evolve with every executed stetp, enriching the information available for future workflow steps.</li> </ul> <pre><code>flowchart TB  \n        subgraph select[Selected Entities]\n            direction TB\n            l1((Location 1))\n            l2((Location 2))\n        end\n        start([Start Workflow]) ===&gt; select\n        subgraph staticacquire[Static Aquires]\n            direction TB\n            subgraph phase1[Phase / Query 1]\n                direction TB\n                l1r1(Router L1-1)\n                l1r2(Router L1-2)\n                l2r1(Router L2-1)\n            end\n            subgraph phase2[Phase / Query 2]\n                direction TB\n                l1s1(Switch L1-1)\n                l1s2(Switch L1-2)\n                l2s1(Switch L2-1)\n            end\n            subgraph phase3[Phase / Query X]\n                direction TB\n                phase3add(..)\n            end\n            phase1 --&gt; phase2\n            phase2 --&gt; phase3\n\n        end\n        select ===&gt; staticacquire\n        subgraph dynamicaquire[Dynamic Aquires over FB]\n            direction TB\n            c1(Configuration Item / Controller eg vManage)\n        end\n        staticacquire ===&gt; dynamicaquire\n        subgraph full[Full Context]\n            direction TB\n            fl1((Location 1))\n            fl2((Location 2))\n            fl1 --&gt; fl1r1(Router L1-1)\n            fl1 --&gt; fl1r2(Router L1-2)\n            fl2 --&gt; fl2r1(Router L2-1)\n            fl1 --&gt; fl1s1(Switch L1-1)\n            fl1 --&gt; fl1s2(Switch L1-2)\n            fl2 --&gt; fl2s1(Switch L2-1)\n            fc1(Configuration Item / Controller eg vManage)\n\n        end\n        dynamicaquire ===&gt;   full\n\nstyle select fill:#b3b1c9\n\nstyle l1 fill:#9de0af\nstyle l2 fill:#9de0af\nstyle fl1 fill:#9de0af\nstyle fl2 fill:#9de0af\n\nstyle staticacquire fill:#b3b1c9\nstyle phase1 fill:#8d8d94\nstyle phase2 fill:#8d8d94\nstyle phase3 fill:#8d8d94\n\nstyle dynamicaquire fill:#b3b1c9\nstyle c1 fill:#837dff\nstyle fc1 fill:#837dff\n\nstyle full fill:#b3b1c9\n\n\nstyle l1r1 fill:#f2f5b5\nstyle l1r2 fill:#f2f5b5\nstyle l2r1 fill:#f2f5b5\nstyle l1s1 fill:#f2f5b5\nstyle l1s2 fill:#f2f5b5\nstyle l2s1 fill:#f2f5b5\nstyle fl1r1 fill:#f2f5b5\nstyle fl1r2 fill:#f2f5b5\nstyle fl2r1 fill:#f2f5b5\nstyle fl1s1 fill:#f2f5b5\nstyle fl1s2 fill:#f2f5b5\nstyle fl2s1 fill:#f2f5b5</code></pre>"},{"location":"neops-task-engine-docs/concept/context/#workflow-data-and-step-results","title":"Workflow Data and Step Results","text":"<p>Each step receives a result from an executed FB per entity. The result is stored in a context object where every FB can use a persistent data store for the duration of the workflow. Additionally there are the well known neops facts are accessable per entity in the datacontext. <pre><code>export interface WorkflowStepContext {\n  global: GlobalContext\n  groups: GroupContexts\n  devices: DeviceContexts\n  interfaces: InterfaceContexts\n  clients: ClientContexts\n  hadError: boolean\n  //current: undefined | GroupContext | DeviceContext | InterfaceContext | ClientContext\n}\n\n  exception: any\n  message: string\n}\n\n\n\nexport type GroupContext = GroupObject &amp; ContextContent\n\nexport interface DeviceObject {\n</code></pre></p>"},{"location":"neops-task-engine-docs/concept/execution/","title":"Workflow Execution","text":"<p>The workflow engine queues every step per entity to be executed by the workers. So for each entity there is a <code>run</code> method call in the worker. Per step and FB the data context and the condition on the steps are defining the entities on which the FB is executed.</p> <pre><code>flowchart TB  \n\n        start([Start Workflow]) ===&gt; wf\n        subgraph wf[Workflow]\n            direction LR\n            subgraph fbs[ ]\n                direction LR\n                fb1 --&gt; fb2 --&gt; fb3\n                subgraph fb1[Function Block 1 per Group]\n                    direction LR\n                    subgraph fb1context[Context FB 1]\n                        direction TB\n                        fb1l1((Location 1))\n                        fb1l2((Location 2))\n                    end\n                    fb1c(Condition FB1) ==&gt; fb1context\n                end\n                subgraph fb2[Function Block 2 per Device]\n                    direction LR\n                    subgraph fb2context[Context FB 2]\n                        direction TB\n                        fb2l1r1(Router L1-1)\n                        fb2l1r2(Router L1-2)\n                        fb2l2r1(Router L2-1)\n                        fb2fc1(Configuration Item / Controller eg vManage)\n                    end\n                    fb2c(Condition FB2) ==&gt; fb2context\n                end\n                subgraph fb3[Function Block 3 per Device]\n                    direction LR\n                    subgraph fb3context[Context FB 3]\n                        direction TB\n                        fb3l1s1(Switch L1-1)\n                        fb3l1s2(Switch L1-2)\n                        fb3l2s1(Switch L2-1)\n                    end\n                    fb3c(Condition FB3) ==&gt; fb3context\n                end\n\n            end\n            subgraph full[Full Context]\n                direction LR\n                fl1((Location 1))\n                fl2((Location 2))\n                fl1 --&gt; fl1r1(Router L1-1)\n                fl1 --&gt; fl1r2(Router L1-2)\n                fl2 --&gt; fl2r1(Router L2-1)\n                fl1 --&gt; fl1s1(Switch L1-1)\n                fl1 --&gt; fl1s2(Switch L1-2)\n                fl2 --&gt; fl2s1(Switch L2-1)\n                fc1(Configuration Item / Controller eg vManage)\n            end\n\n            full --&gt; fb1c\n            full --&gt; fb2c\n            full --&gt; fb3c\n\n        end\n\n\nstyle fb1 fill:#8d8d94\nstyle fb2 fill:#8d8d94\nstyle fb3 fill:#8d8d94\n\nstyle fc1 fill:#837dff\nstyle fb2fc1 fill:#837dff\n\nstyle full fill:#b3b1c9\nstyle fb1context fill:#b3b1c9\nstyle fb2context fill:#b3b1c9\nstyle fb3context fill:#b3b1c9\n\n\nstyle fb2l1r1 fill:#f2f5b5\nstyle fb2l1r2 fill:#f2f5b5\nstyle fb2l2r1 fill:#f2f5b5\nstyle fb3l1s1 fill:#f2f5b5\nstyle fb3l1s2 fill:#f2f5b5\nstyle fb3l2s1 fill:#f2f5b5\nstyle fl1r1 fill:#f2f5b5\nstyle fl1r2 fill:#f2f5b5\nstyle fl2r1 fill:#f2f5b5\nstyle fl1s1 fill:#f2f5b5\nstyle fl1s2 fill:#f2f5b5\nstyle fl2s1 fill:#f2f5b5\n\n</code></pre>"},{"location":"neops-task-engine-docs/concept/transaction/","title":"Transaction","text":""},{"location":"neops-task-engine-docs/concept/transaction/#workflows","title":"Workflows","text":"<pre><code>flowchart TD\n    subgraph Transaction1\n        subgraph Workflow1\n            wf1_start[\"Start\"] --&gt; wf1_fb1(\"Function Block\")\n            wf1_fb1 --&gt; wf1_wf2(\"Workflow (embdeded)\")\n            wf1_wf3(\"Workflow (dispatched)\") --&gt; wf1_fb2(\"Function Block\")\n            wf1_fb2 --&gt; wf1_end[\"End\"]\n        end\n        style Workflow1 fill:#B9EAC9,stroke:#333,stroke-width:2px\n\n        subgraph Workflow2\n            wf1_wf2 --&gt; wf2_start[\"Start\"]\n            wf2_start --&gt; wf2_fb1(\"Function Block\")\n            wf2_fb1 --&gt; wf2_end[\"End\"]\n            wf2_end --&gt; wf1_wf3\n        end\n        style Workflow2 fill:#FFCFCFFF,stroke:#333,stroke-width:2px\n    end\n\n    subgraph Transaction2\n        subgraph Workflow3\n            wf1_wf3 --&gt; wf3_start[\"Start\"]\n            wf3_start --&gt; wf3_fb1(\"Function Block\")\n            wf3_fb1 --&gt; wf3_end[\"End\"]\n        end\n        style Workflow3 fill:#FFEBA8FF,stroke:#333,stroke-width:2px\n    end</code></pre>"},{"location":"neops-task-engine-docs/concept/transaction/#aquiring-and-locking","title":"Aquiring and locking","text":"<p>Aquiring is done to populate the context of a workflow and apply locks on entities. All entities can have a lock applied, if a workflow/function block/step is run on them.</p> <pre><code>flowchart LR\n    subgraph Acquisition phase\n        entities[\"Acquire entities\"] --&gt; aquire_global[\"Acquire global\"]\n        aquire_global --&gt; aquire_step[\"Acquire per step\"]\n        aquire_step --&gt; lock((\"Create lock\"))\n    end\n\n    subgraph Transation\n        lock --&gt; step1(\"Step 1\")\n        step1 --&gt; step2(\"Step 2\")\n        step2 --&gt; step3(\"Step 3\")\n    end</code></pre>"},{"location":"neops-task-engine-docs/concept/transaction/#steps","title":"Steps","text":"<ul> <li>Acquire entities: Selected entities getting aquired.</li> <li>Acquire global: Acquiring statically defined entities (add &amp; remove functionallity)</li> <li>Acquire per step: Dynamic acquisition of entities based on configuration of each step (embeded/sub workflow, function block)</li> <li>Lock: Create lock on acquired entities based on locking type and strategy</li> <li>Transation: Start execution the steps of the worklow</li> </ul>"},{"location":"neops-task-engine-docs/concept/transaction/#locking-types","title":"Locking types","text":"Typ Read Write Read lock okMultiple users or processes can read the entity concurrently when it is under a read lock. nokNo user or process is allowed to modify the entity while it is under a read lock. Write lock nokNo users or processes can access the entity for reading while it is under a write lock. nokOnly the user who holds the lock can write or modify the entity."},{"location":"neops-task-engine-docs/concept/transaction/#locking-strategy","title":"Locking strategy","text":"Strategy Read lock behavior Write lock behavior Normal sameMultiple reads allowed, no writes sameOnly one user can write; all others blocked Loose sameMultiple reads allowed, no writes Multiple writes allowed, reads also permitted"},{"location":"neops-task-engine-docs/make_scripts/mkdocs-documentation/docs_template/","title":"Your project documentation","text":""},{"location":"neops-task-engine-docs/make_scripts/mkdocs-documentation/docs_template/#next-steps","title":"Next steps","text":"<p>If you want to include this documentation as a sub-documentation in another repository, add the following line to the <code>mkdocs_custom.yml</code> of the other repository.</p> <pre><code>cd submodules\ngit submodule add your-repo-name\n</code></pre> <pre><code>- Your project documentation: '!include ./submodules/your-repo-name/mkdocs.yml'\n</code></pre>"},{"location":"neops-task-engine-docs/make_scripts/mkdocs-documentation/docs_template/#reference","title":"Reference","text":"<ul> <li>Markdown/Material for MkDocs: https://squidfunk.github.io/mkdocs-material/reference/</li> <li>Snippets: https://facelessuser.github.io/pymdown-extensions/extensions/snippets/</li> </ul>"},{"location":"neops-task-engine-docs/schema/","title":"Index","text":"<p>Workflow Schema</p>"},{"location":"neops-task-runner-python-docs/","title":"Your project documentation","text":""},{"location":"neops-task-runner-python-docs/#next-steps","title":"Next steps","text":"<p>If you want to include this documentation as a sub-documentation in another repository, add the following line to the <code>mkdocs_custom.yml</code> of the other repository.</p> <pre><code>cd submodules\ngit submodule add your-repo-name\n</code></pre> <pre><code>- Your project documentation: '!include ./submodules/your-repo-name/mkdocs.yml'\n</code></pre>"},{"location":"neops-task-runner-python-docs/#reference","title":"Reference","text":"<ul> <li>Markdown/Material for MkDocs: https://squidfunk.github.io/mkdocs-material/reference/</li> <li>Snippets: https://facelessuser.github.io/pymdown-extensions/extensions/snippets/</li> </ul>"},{"location":"neops-web-client-docs/","title":"Your project documentation","text":""},{"location":"neops-web-client-docs/#next-steps","title":"Next steps","text":"<p>If you want to include this documentation as a sub-documentation in another repository, add the following line to the <code>mkdocs_custom.yml</code> of the other repository.</p> <pre><code>cd submodules\ngit submodule add your-repo-name\n</code></pre> <pre><code>- Your project documentation: '!include ./submodules/your-repo-name/mkdocs.yml'\n</code></pre>"},{"location":"neops-web-client-docs/#reference","title":"Reference","text":"<ul> <li>Markdown/Material for MkDocs: https://squidfunk.github.io/mkdocs-material/reference/</li> <li>Snippets: https://facelessuser.github.io/pymdown-extensions/extensions/snippets/</li> </ul>"},{"location":"neops-web-client-docs/make_scripts/mkdocs-documentation/docs_template/","title":"Your project documentation","text":""},{"location":"neops-web-client-docs/make_scripts/mkdocs-documentation/docs_template/#next-steps","title":"Next steps","text":"<p>If you want to include this documentation as a sub-documentation in another repository, add the following line to the <code>mkdocs_custom.yml</code> of the other repository.</p> <pre><code>cd submodules\ngit submodule add your-repo-name\n</code></pre> <pre><code>- Your project documentation: '!include ./submodules/your-repo-name/mkdocs.yml'\n</code></pre>"},{"location":"neops-web-client-docs/make_scripts/mkdocs-documentation/docs_template/#reference","title":"Reference","text":"<ul> <li>Markdown/Material for MkDocs: https://squidfunk.github.io/mkdocs-material/reference/</li> <li>Snippets: https://facelessuser.github.io/pymdown-extensions/extensions/snippets/</li> </ul>"},{"location":"neops-web-sdk-docs/","title":"Your project documentation","text":""},{"location":"neops-web-sdk-docs/#next-steps","title":"Next steps","text":"<p>If you want to include this documentation as a sub-documentation in another repository, add the following line to the <code>mkdocs_custom.yml</code> of the other repository.</p> <pre><code>cd submodules\ngit submodule add your-repo-name\n</code></pre> <pre><code>- Your project documentation: '!include ./submodules/your-repo-name/mkdocs.yml'\n</code></pre>"},{"location":"neops-web-sdk-docs/#reference","title":"Reference","text":"<ul> <li>Markdown/Material for MkDocs: https://squidfunk.github.io/mkdocs-material/reference/</li> <li>Snippets: https://facelessuser.github.io/pymdown-extensions/extensions/snippets/</li> </ul>"},{"location":"neops-web-sdk-docs/make_scripts/mkdocs-documentation/docs_template/","title":"Your project documentation","text":""},{"location":"neops-web-sdk-docs/make_scripts/mkdocs-documentation/docs_template/#next-steps","title":"Next steps","text":"<p>If you want to include this documentation as a sub-documentation in another repository, add the following line to the <code>mkdocs_custom.yml</code> of the other repository.</p> <pre><code>cd submodules\ngit submodule add your-repo-name\n</code></pre> <pre><code>- Your project documentation: '!include ./submodules/your-repo-name/mkdocs.yml'\n</code></pre>"},{"location":"neops-web-sdk-docs/make_scripts/mkdocs-documentation/docs_template/#reference","title":"Reference","text":"<ul> <li>Markdown/Material for MkDocs: https://squidfunk.github.io/mkdocs-material/reference/</li> <li>Snippets: https://facelessuser.github.io/pymdown-extensions/extensions/snippets/</li> </ul>"},{"location":"neops-web-sdk-docs/neops-schematics/","title":"Index","text":""},{"location":"neops-web-sdk-docs/neops-schematics/#compiling-neops-schematics","title":"Compiling <code>neops-schematics</code>","text":"<p>Before running any <code>ng generate</code> commands, ensure that the <code>neops-schematics</code> are both compiled and linked to the project. This process is automatically handled after any <code>npm install</code>.</p>"},{"location":"neops-web-sdk-docs/neops-schematics/#post-installation-process","title":"Post-Installation Process","text":"<p>After running <code>npm install</code>, the following postinstall script will automatically build the <code>neops-schematics</code>:</p> <pre><code>{\n  \"postinstall\": \"npm run build-schematics\"\n}\n</code></pre>"},{"location":"neops-web-sdk-docs/neops-schematics/#build-script","title":"Build Script","text":"<ol> <li>Build the Schematics:    This script compiles the <code>neops-schematics</code> by navigating to the <code>neops-schematics</code> directory and running the build command:</li> </ol> <pre><code>{\n  \"build-schematics\": \"cd ./neops-schematics &amp;&amp; npm run build\"\n}\n</code></pre>"},{"location":"neops-web-sdk-docs/neops-schematics/#using-neops-schematics-for-dashboard-card-db-c","title":"Using <code>neops-schematics</code> for dashboard-card (db-c)","text":"<p>There are two ways to use the <code>neops-schematics:db-c</code> for generating components. The command can be run from the <code>dashboard</code> directory or from the root directory of the <code>neops-web-sdk</code> project. <code>Attention</code>: There is no need to put <code>dashboard-card-</code> before the name, schematics will do it.</p>"},{"location":"neops-web-sdk-docs/neops-schematics/#example-usage","title":"Example Usage:","text":"<ol> <li>From the Dashboard Directory:    If the <code>dashboard</code> directory is being used, the following command can be used to generate a component:</li> </ol> <pre><code>   ng generate neops-schematics:db-c &lt;component-name&gt;\n   ng generate neops-schematics:db-c test-component\n</code></pre> <ol> <li>From the Root Directory of <code>neops-web-sdk</code>:    If the root directory of the <code>neops-web-sdk</code> project is being used, then use the following command:</li> </ol> <pre><code>   ng generate neops-schematics:db-c &lt;component-name&gt; --project=&lt;project-name&gt;\n   ng generate neops-schematics:db-c test-component --project=@zebbra/ngx-neops-app-components\n</code></pre>"},{"location":"neops-web-sdk-docs/neops-schematics/#important-notice","title":"Important Notice","text":"<p>The files found in the <code>neops-schematics/src/utils</code> directory belong to an older version of Angular schematics, and most of them are no longer supported in the newer versions of Angular schematics. It is important to review the latest Angular utility functions before using or modifying these files. For more information about the original source of the utils directory functions: Angular CLI - Schematics Utility</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-jsonforms-carbon/","title":"NgxJsonformsCarbon","text":"<p>This library was generated with Angular CLI version 13.3.0.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-jsonforms-carbon/#code-scaffolding","title":"Code scaffolding","text":"<p>Run <code>ng generate component component-name --project ngx-jsonforms-carbon</code> to generate a new component. You can also use <code>ng generate directive|pipe|service|class|guard|interface|enum|module --project ngx-jsonforms-carbon</code>.</p> <p>Note: Don't forget to add <code>--project ngx-jsonforms-carbon</code> or else it will be added to the default project in your <code>angular.json</code> file.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-jsonforms-carbon/#build","title":"Build","text":"<p>Run <code>ng build ngx-jsonforms-carbon</code> to build the project. The build artifacts will be stored in the <code>dist/</code> directory.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-jsonforms-carbon/#publishing","title":"Publishing","text":"<p>After building your library with <code>ng build ngx-jsonforms-carbon</code>, go to the dist folder <code>cd dist/ngx-jsonforms-carbon</code> and run <code>npm publish</code>.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-jsonforms-carbon/#running-unit-tests","title":"Running unit tests","text":"<p>Run <code>ng test ngx-jsonforms-carbon</code> to execute the unit tests via Karma.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-jsonforms-carbon/#further-help","title":"Further help","text":"<p>To get more help on the Angular CLI use <code>ng help</code> or go check out the Angular CLI Overview and Command Reference page.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-components/","title":"NgxNeopsAppComponents","text":"<p>This library was generated with Angular CLI version 13.1.0.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-components/#code-scaffolding","title":"Code scaffolding","text":"<p>Run <code>ng generate component component-name --project ngx-neops-app-components</code> to generate a new component. You can also use <code>ng generate directive|pipe|service|class|guard|interface|enum|module --project ngx-neops-app-components</code>.</p> <p>Note: Don't forget to add <code>--project ngx-neops-app-components</code> or else it will be added to the default project in your <code>angular.json</code> file.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-components/#build","title":"Build","text":"<p>Run <code>ng build ngx-neops-app-components</code> to build the project. The build artifacts will be stored in the <code>dist/</code> directory.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-components/#publishing","title":"Publishing","text":"<p>After building your library with <code>ng build ngx-neops-app-components</code>, go to the dist folder <code>cd dist/ngx-neops-app-components</code> and run <code>npm publish</code>.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-components/#running-unit-tests","title":"Running unit tests","text":"<p>Run <code>ng test ngx-neops-app-components</code> to execute the unit tests via Karma.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-components/#further-help","title":"Further help","text":"<p>To get more help on the Angular CLI use <code>ng help</code> or go check out the Angular CLI Overview and Command Reference page.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-components/#jsonforms-documentation","title":"JsonForms Documentation","text":""},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-components/#uischema-layouts-and-rules","title":"UiSchema, Layouts and Rules:","text":"<p>For the official and complete library documentation refer to: jsonforms.io documentation</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-components/#types","title":"Types:","text":"<p>This is an overview of the types that are currently supported by the library and how to use them.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-components/#boolean","title":"Boolean","text":"<p><code>\"example\":{\"type\":\"boolean\"}</code></p> <ul> <li>Defaults to a checkbox.</li> <li>Use <code>\"options\":{\"toggle\":true}</code> in the UiSchema to render a toggle.</li> </ul>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-components/#integer","title":"Integer","text":"<p><code>\"example\":{\"type\":\"integer\"}</code></p> <ul> <li>Renders an integer input field.</li> </ul>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-components/#number","title":"Number","text":"<p><code>\"example\":{\"type\":\"number\"}</code></p> <ul> <li>Defaults to a number input field.</li> <li>Use <code>\"options\":{\"slider\":true}</code> in the UiSchema to render a slider. In the JsonSchema you can define min., max and   default   values.<code>{\"type\":\"number\",\"minimum\":1,\"maximum\":5,\"default\":2}</code> jsonforms.io example</li> </ul>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-components/#string","title":"String","text":"<p><code>\"example\":{\"type\":\"string\"}</code></p> <ul> <li>Defaults to a string input field.</li> <li>Use date, time, date-time, email, jinja2 or json as the format in the JsonSchema to render corresponding input fields,   eg. <code>date: {type: 'string',format: 'date'}</code></li> <li>Use <code>example: {type: 'string',enum:['One','Two','Three']}</code> to render a searchable dropdown populated with One, Two   and Three.</li> </ul>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-components/src/lib/dashboard/","title":"Neops Dashboard","text":""},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-components/src/lib/dashboard/#create-new-card","title":"Create new card","text":"<pre><code>ng generate neops-schematics:db-c &lt;component-name&gt;\n</code></pre> <p>See more in the neops schematics</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-services/","title":"NgxNeopsAppServices","text":"<p>This library was generated with Angular CLI version 13.1.0.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-services/#code-scaffolding","title":"Code scaffolding","text":"<p>Run <code>ng generate component component-name --project ngx-neops-app-services</code> to generate a new component. You can also use <code>ng generate directive|pipe|service|class|guard|interface|enum|module --project ngx-neops-app-services</code>.</p> <p>Note: Don't forget to add <code>--project ngx-neops-app-services</code> or else it will be added to the default project in your <code>angular.json</code> file.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-services/#build","title":"Build","text":"<p>Run <code>ng build ngx-neops-app-services</code> to build the project. The build artifacts will be stored in the <code>dist/</code> directory.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-services/#publishing","title":"Publishing","text":"<p>After building your library with <code>ng build ngx-neops-app-services</code>, go to the dist folder <code>cd dist/ngx-neops-app-services</code> and run <code>npm publish</code>.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-services/#running-unit-tests","title":"Running unit tests","text":"<p>Run <code>ng test ngx-neops-app-services</code> to execute the unit tests via Karma.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-app-services/#further-help","title":"Further help","text":"<p>To get more help on the Angular CLI use <code>ng help</code> or go check out the Angular CLI Overview and Command Reference page.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-client/","title":"NgxNeopsClient","text":"<p>This library was generated with Angular CLI version 13.1.0.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-client/#code-scaffolding","title":"Code scaffolding","text":"<p>Run <code>ng generate component component-name --project ngx-neops-client</code> to generate a new component. You can also use <code>ng generate directive|pipe|service|class|guard|interface|enum|module --project ngx-neops-client</code>.</p> <p>Note: Don't forget to add <code>--project ngx-neops-client</code> or else it will be added to the default project in your <code>angular.json</code> file.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-client/#build","title":"Build","text":"<p>Run <code>ng build ngx-neops-client</code> to build the project. The build artifacts will be stored in the <code>dist/</code> directory.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-client/#publishing","title":"Publishing","text":"<p>After building your library with <code>ng build ngx-neops-client</code>, go to the dist folder <code>cd dist/ngx-neops-client</code> and run <code>npm publish</code>.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-client/#running-unit-tests","title":"Running unit tests","text":"<p>Run <code>ng test ngx-neops-client</code> to execute the unit tests via Karma.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-client/#further-help","title":"Further help","text":"<p>To get more help on the Angular CLI use <code>ng help</code> or go check out the Angular CLI Overview and Command Reference page.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-sdk-artifacts/","title":"NgxNeopsSdkArtifacts","text":"<p>This library contains global styles.scss and font-overrides to reused in neops projects</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-storage-client/","title":"NgxNeopsStorageClient","text":"<p>This library was generated with Angular CLI version 13.3.0.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-storage-client/#code-scaffolding","title":"Code scaffolding","text":"<p>Run <code>ng generate component component-name --project ngx-neops-storage-client</code> to generate a new component. You can also use <code>ng generate directive|pipe|service|class|guard|interface|enum|module --project ngx-neops-storage-client</code>.</p> <p>Note: Don't forget to add <code>--project ngx-neops-storage-client</code> or else it will be added to the default project in your <code>angular.json</code> file.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-storage-client/#build","title":"Build","text":"<p>Run <code>ng build ngx-neops-storage-client</code> to build the project. The build artifacts will be stored in the <code>dist/</code> directory.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-storage-client/#publishing","title":"Publishing","text":"<p>After building your library with <code>ng build ngx-neops-storage-client</code>, go to the dist folder <code>cd dist/ngx-neops-storage-client</code> and run <code>npm publish</code>.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-storage-client/#running-unit-tests","title":"Running unit tests","text":"<p>Run <code>ng test ngx-neops-storage-client</code> to execute the unit tests via Karma.</p>"},{"location":"neops-web-sdk-docs/projects/zebbra/ngx-neops-storage-client/#further-help","title":"Further help","text":"<p>To get more help on the Angular CLI use <code>ng help</code> or go check out the Angular CLI Overview and Command Reference page.</p>"},{"location":"neops-web-sdk-docs/src/app/pages/dashboard-demo/data/markdown/","title":"Neops Dashboard","text":"<p>This is a Demo of the neops Dashboard. The config will look like below and may in a first iteration provided by zebbra, and later configured by the user.</p> <p>There will be one Dashboard per scope, and possibly we will add also the possibility for users to add private Dashboards</p> <pre><code>;[\n  {\n    gridConfig: {\n      x: 0,\n      y: 0,\n      rows: 2,\n      cols: 2,\n    },\n    cardConfig: {\n      cardId: 'markdown',\n      data: {\n        text: 'my markdown text',\n      },\n    },\n  },\n  {\n    // more card configs\n  },\n]\n</code></pre>"}]}