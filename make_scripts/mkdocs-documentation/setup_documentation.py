from pathlib import Path

import deepmerge
import yaml
import subprocess
import os
import shutil

MKDOCS_BASE = "make_scripts/mkdocs-documentation/mkdocs_base.yml"
MKDOCS_CUST_TEMPLATE = "make_scripts/mkdocs-documentation/mkdocs_custom.yml"
MKDOCS_DOCS_TEMPLATE = "make_scripts/mkdocs-documentation/docs_template"

MKDOCS_CUST = "mkdocs_custom.yml"
MKDOCS_RES = "mkdocs.yml"

RES_HEADER = """# 
# -------------------------------------------
# 
# THIS FILE IS AUTOGENERATED, DO NOT EDIT!
# Instead, perform your changes or extensions (to mkdocs_base.yml) in mkdocs_custom.yml
# These files will be merged together into mkdocs.yml (this file)
# 
# -------------------------------------------
# 
"""


class SafeLoaderIgnoreUnknown(yaml.SafeLoader):
    """
    A safe loader that passes unknown values through unchanged
    """
    def pass_unknown(self, node):
        return node.tag


def is_file_dirty(filename):
    """
  Checks if a specific file is dirty (modified but not staged) in the Git index.

  Args:
      filename: The path to the file to check.

  Returns:
      True if the file is dirty, False otherwise.
  """
    # Check if file exists first
    if not os.path.exists(filename):
        return False
    # Run git diff-index to compare the working tree with the index for the file
    command = ["git", "diff-index", "--quiet", "--cached", "HEAD", filename]
    # Use subprocess.run with capture_output to capture the command's output
    result = subprocess.run(command, capture_output=True)
    # Check the returncode. Non-zero indicates a difference (dirty file)
    return result.returncode != 0


def read_file(file_name):
    with open(file_name) as f:
        return f.read()


def write_file(file_name, content):
    with open(file_name, "w") as f:
        f.write(content)


def merge_mkdocs_yml():
    SafeLoaderIgnoreUnknown.add_constructor(None, SafeLoaderIgnoreUnknown.pass_unknown)

    yaml_base = yaml.load(read_file(MKDOCS_BASE), Loader=SafeLoaderIgnoreUnknown)
    yaml_custom = yaml.load(read_file(MKDOCS_CUST), Loader=SafeLoaderIgnoreUnknown)

    yaml_res = deepmerge.always_merger.merge(yaml_base, yaml_custom)

    if not is_file_dirty(MKDOCS_RES):
        write_file(MKDOCS_RES, RES_HEADER + yaml.dump(yaml_res).replace("tag:yaml.org,2002:", "!!").replace("'!relative'", "!relative"))
    else:
        raise Exception(f"{MKDOCS_RES} is dirty, stage or commit first")


def ensure_mkdocs_custom():
    if not os.path.exists(MKDOCS_CUST):
        shutil.copy(MKDOCS_CUST_TEMPLATE, MKDOCS_CUST)

def ensure_docs_dir():
    """
    Ensures that the docs directory exists and contains an index.md.
    If not, create it with an index.md
    """

    if not os.path.exists("docs"):
        shutil.copytree(MKDOCS_DOCS_TEMPLATE, "docs")


def is_ignored_by_git(path):
    # Use git check-ignore command to see if the path is ignored
    result = subprocess.run(['git', 'check-ignore', path], capture_output=True, text=True)

    # If the result's stdout is not empty, the path is ignored
    return result.stdout != ''

def create_symlinks():
    """
    Create symlinks for all folders in the root of the directory to enable snippets in the documentation
    :return:
    """
    path = '.'
    directories = [d for d in os.listdir(path) if os.path.isdir(os.path.join(path, d))]

    config = yaml.load(read_file(MKDOCS_RES), Loader=SafeLoaderIgnoreUnknown)

    docs_dir = Path(config.get("docs_dir", "./docs"))

    symlinks = [f for f in docs_dir.iterdir() if f.is_symlink()]

    for dir in directories:
        if is_ignored_by_git(dir):
            print(f"-- Skipping {dir} (git-ignored)")
            continue
        if dir.startswith("."):
            print(f"-- Skipping {dir} (hidden directory)")
            continue
        if dir.startswith("node_modules"):
            print(f"-- Skipping {dir} (node_modules)")
            continue
        if dir.startswith("submodules"):
            print(f"-- Skipping {dir} (submodules need to be referenced directly)")
            continue
        if dir.endswith(docs_dir.name):
            print(f"-- Skipping {dir} (docs directory)")
            continue
        if symlinks not in symlinks:
            dest = f"{docs_dir}/{dir}"
            print(f"-- Skipping {dir} (already exists)")
            if Path(dest).exists():
                continue
            rel_dir = os.path.relpath(dir, docs_dir)
            os.symlink(rel_dir, dest, target_is_directory=True)
            print(f"++ Created symlink for {dir}")

    print("You can now implement files from all folders in your repo within the docs")




def main():
    ensure_mkdocs_custom()
    merge_mkdocs_yml()
    ensure_docs_dir()
    create_symlinks()


if __name__ == '__main__':
    main()
